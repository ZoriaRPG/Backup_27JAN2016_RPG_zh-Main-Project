//Docs for 2.50.2
//rev 0.4.3
//20th Dec, 2015

Search for !#! to find areas that require completion. 
?REFFFC? What is this?

//===================================================================================
//                 --- ZScript built-in functions and variables ---
//===================================================================================
/*
* 	These functions are all INTERNAL to ZQuest. They require no header
* 	or other import directives to work, and are all direct representations
* 	of ZASM instructions. 
*
* 	These functions and commands are the BASIC BUILDING BLOCKS of ZScript:
* 	While they require no other functions to work, ALL other functions 
* 	in headers (such as std.zh) RELY, and OPERATE using these functions.
*
*	Thus, it is essential to know what each of these does, how they work,
* 	and how to use them. 
*
* 	For other included functions, that are not internal (i.e. external functions)
* 	please read the documentation specific to  each header. These are individual 
* 	files (e.g. std.txt), however if you wish to view all the pre-packaged ZScript
* 	functions, and commands, you may view the EXTENDED DOCUMENTATION, as
* 	those documentation files contain all of the 'Essential ZScript' that
* 	you will want to use.
*
* 	Where possible, the ZASM instruction used by the functions, and the
* 	commands detailed herein are listed inline with the entry for the related
* 	function / command. Full (public) ZASM documentation is, sadly incomplete.
*
* 	Note: Functions and variables other than global functions are properties
* 	of **objects**. Objects are divided into NAMESPACEs and CLASSes, and the 
* 	the syntax for using them is:
*
* 	[object name]->[property]
*
* 	where "[object name]" is the object's name (e.g. Link, Game, Screen)/
* 	and "[property]" is the funcion. 
*	
* 	Example:
* 	void GetCurDMap() is a Game property, and is called as:
*
* 	Game->GetCurDMap();
*
* 	"Link", "Screen" and "Game" are always available and don't need to be 
* 	instantiated, while you must initialise other classes, such as ffc, item,
* 	and npc.
*
* 	ZScript functions are of the types: int, float, bool, and void. Of these,
* 	only void does not return a value. (The void type is normally used to run
* 	a series of instructions, or to set values). The other types retrun values
* 	appropriate to their type.
*
* 	Note: In the following, "int" indicates that a parameter is truncated by a 
* 	function to an integer, or that the return value will always be an integer 
* 	however, ZScript itself makes no distinction between int and float types.
*/

/************************************************************************************************************/

//////////////////
/// ZASM Flags ///
//////////////////

ZASM uses a series of special flags, to determine how it should follow logical instructions,
including the following:

SCRIPT FLAGS
TRUEFLAG : A condition in the script, is true
MOREFLAG : Must be set manually with ZASM. 
FALSEFLAG : Must be set namually with ZASM. 
LESSFLAG : Must be set manually with ZASM.

Instructions
SETTRUE : Set the Script Flag TRUEFLAG.
	SETTRUE Sets a true condition for the Assembler, if a COMPARERV and COMPARER validate.
	This is used when making statements in ZScript. 
SETFALSE: Set the Script Flag FALSEFLAG: ZScript does not do this. 
SETMORE : Set the Script FLag MOREFLAG: ZScript does not do this. 
SETLESS : Set the Script Flag LESSFLAG: ZScript does not do this. 

These flags are used in evaluation instructions, to determine if an instruction should run.

Examples of these are as follows:

GOTOTRUE: Executes the GOTO instruction only if the Script Flag TRUEFLAG is enabled.
GOTOFALSE: Executes the GOTO instruction only if the Script Flag FALSEFLAG is enabled.
GOTOMORE: Executes the GOTO instruction only if the Script Flag MOREFLAG is enabled.
GOTOLESS: Executes the GOTO instruction only if the Script Flag LESSFLAG is enabled.

In contrast, GOTO/GOTOR ignore all flags, and conditions.

ZScript always compiles down to GOTO, GOTOR, and GOTOTRUE instructions. 
The other FLAG-typed GOTO instruction types are valid only in ZASM, and serve no useful purpose.
GOTOLESS, GOTOMORE, and GOTOFALSE are effectively deprecated. 

//=======================================================
//--- Instruction Processing Order and General Timing ---
=========================================================

1.     Instructions in Global script Init (if starting a new game)
2.     Instructions in Global Script OnContinue (is resuming a game)
3.     Instructions immediately inside the run() function of a global active script. 
4.     Instructions in the global active script's infinite loop prior to Waitdraw, 
       if (5) does not exist, or on the first frame of the game. 
5.     Instructions from an ffc script positioned after (an illegal) 
       Waitdraw() instruction in that script from the previous frame. 
	     Note: Requires being on at least the second frame of a game session.
6.     Instructions in the global active script prior to Waitdraw(). 
7.     Instructions in an ffc script, other than (5), excluding draw commands. 
8.     Screen Scrolling (2.50.2, or later)
9.     Instructions from item scripts. 
10.    Waitdraw() in a global active script. 
11.    Instructions in the global active script, called after Waitdraw()
11(b). Screen Scrolling ( 2.50.0, and 2.50.1 )
12.    Drawing from FFCs
13.    Instructions in an OnExit script, if the game is exiting. 
14.    Return to (5).


/************************************************************************************************************/

//========================
//--- Global Functions ---
//========================

/////////////////////////
/// General Functions ///
/////////////////////////


void Waitdraw();		ZASM Instruction:
				WAITDRAW
/**
* Halts execution of the script until ZC's internal code has been run (movement,
* collision detection, etc.), but before the screen is drawn. This can only
* be used in the active global script.
* Waitdraw() may only be called from the global active script; not from FFC scripts.
* The sequence of ZC actions is as follows:

* FFCs (in numerical sequence, from FFC 01, to FFC 32)
* Enemies
* EWeapons
* Link
* LWeapons
* Hookshot
* Collision Checking
* Store Link->Input / Link->Press
* Waitdraw()
* Drawing
* Rendering of the Screen
* Screen Scrolling
* Drawing from FFCs
*
* Note: Drawing from FFCs technically occurs with other Drawing, but as it is issued after Waitdraw(),  
* it is offset (a frame late) and renders after screen scrolling, and after any other drawing in the same 
* frame as draw instructions from ffcs are called. To ensure that drawing done by ffcs is in sync with 
* other drawing, it is imperative to call it from your global script, using the ffc to trigger global 
* conditions that cause global drawing instructions that are called before Waitdraw() in your global 
* active script to evaluate true. 
*
* Anything placed after Waitdraw() will not present graphical effects until the next frame. 
* It is possible { ! CHECK } to read/store Link->Tile, Link->Dir and other variables *after( Waitdraw()
* in one frame, and then use these values to modify other pointer members so that they are drawn correctly
* at the next execution of Waitdraw().
*
*
*/ Example Use:

	Waitdraw();
	
*//////////////////////////////
* Waitdraw() in ffc scripts ///
* --------------------------///
* Althouth technically illegal, it is possible to call Waitdraw() in an *ffc script*. Doing this has the 
* following effects, and/or consequences:
* 
* 1. The Compiler will report an error, and print the error to Allegro log:
*	'Warning: Waitdraw() may only be used in global scripts.'
* 2. Any instruction sint he ffc script that are called before the Waitdraw() instruction in the ffc script 
*    will run this frame, after Waitdraw() in your global active script.
* 3. Any instructions called *after* Waitdraw() in the ffc script, will run BEFORE BOTH Waitdraw() in your
*    global active script, and BEFORE any other instructions in your global active script's infinite loop. 
*
* This behaviour may change in future versions of ZC, and using Waitdraw() in ffc scripts is not advised. 

*///////////////////////////////
* Waitdraw() in item scripts ///
* ---------------------------///
* Althouth technically illegal, it is possible to call Waitdraw() in an item sctipt. Doing this has the 
* following effects, and/or consequences:
* 
* 1. The Compiler will report an error, and print the error to Allegro log:
*	'Warning: Waitdraw() may only be used in global scripts.'
* 2.
*
* This behaviour may change in future versions of ZC, and using Waitdraw() in item scripts is not advised. 

/************************************************************************************************************/

void Waitframe();		ZASM Instruction:
				WAITFRAME
/**
* Temporarily halts execution of the current script. This function returns at
* the beginning of the next frame of gameplay.
* Slots 1, 3 and 4 Global scripts and item scripts only execute for one frame,
* so in those scripts Waitframe() is essentially Quit().
* It is safe to call Waitframe in the active global script.
* A Waitframe is required in all infinite loops (e.g. while(true) ) so that ZC may 
* pause to break in order to advance to the next frame, then resume the loop from the start.
*
*/ Example Use:

	Waitframe();
	
*///////////////////////////////
* Waitdraw() in item scripts ///
* ---------------------------///
* Althouth technically legal, it is invalid to call Waitframe() in an item sctipt. Doing this has the 
* following effects, and/or consequences:
* 
* 1. The script will prematurely exit. 
*
* Calling Waitframe() in an item script is effectively identical to calling Quit(), however this behaviour 
* may change in future versions of ZC, and using Waitframe() in item scripts is not advised. 

/************************************************************************************************************/

void Quit();			ZASM Instruction:
				QUIT
/**
* Terminates execution of the current script. Does not return.
* Caution: If called from a global script, the script itself exits.
*
*/ Example Use:

	Quit();

/************************************************************************************************************/

//////////////////////////////////////
/// Poke, or Peek at Memory Values ///
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/// The following functions are used by ZScript to build arrays, and move data between the registers  ///
/// that hold them, and generally interpret the values in registers for using arrays.                 ///
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/// When an array is declared in ZScript, the following commands are used to create it,               ///
/// and store its values:
///
///
//////////////////
/// When an array is accessed, and the value of an index read, these instructions:
///
///
///
//////////////////
/// When the values in an array are modified, these instrictions:
///
///
///////////////////////////////////////////////////////////////////////////////////////////////////////
/// Using these, it would be possible to generate your own array handling routines.
//////////////////////////////////////////////////////////////////////////////////////////////////////


// Peek at RAM value in a global address.

void GetGlobalRAM(int register)		ZASM Instruction: 
					GLOBALRAMD
Example Use:
	Game->GetGlobalRAM(10)
	Returns the value in gd10

/************************************************************************************************************/

// POKE value into Global address

void SetGlobalRAM(int register, int value)	ZASM Instruction: 
						GLOBALRAMD<><>
Example Use:
	Game->SetGlobalRAM(10,6)
	Sets gd10 to a value of '6'.

/************************************************************************************************************/

//Peek at register value of specific script address.
void GetScriptRAM(int register)			ZASM Instruction: 
						SCRIPTRAMD<>
Example Use:
	Game->GetScriptRAM(4)
	Returns the value of Script RAM register 4.

/************************************************************************************************************/

//POKE Vakue into Script RAM address
void SetScriptRAM(int register, int value)	ZASM Instruction: 
						SCRIPTRAMD<><>
Example Use:
	Game->SetScriptRAM(4,12)
	Sets script RAM register 4 to a value of '12'

/************************************************************************************************************/

////////////////////
/// Undocumented ///
////////////////////

//! These are in the source code, but have no documentation, at all, at all. 
//! I'm unsure of the intended use, or what a 'colour buffer' means. 

void SetColorBuffer( 	int amount, int offset,		ZASM Instruction: 
			int stride, int *ptr )		SETCOLORB

Opcode: OSetColorBufferRegister()
Example Use: 

/************************************************************************************************************/

void GetColorBuffer(	int amount, int offset, 	ZASM Instruction: 
			int stride, int *ptr )		GETCOLORB
			
Opcode: OGetColorBufferRegister();
Exaple Use:

/************************************************************************************************************/

void SetDepthBuffer(	int amount, int offset, 	ZASM Instruction: 
			int stride, int *ptr )		SETDEPTHB
			
Opcode: OSetDepthBufferRegister();
Example Use:

/************************************************************************************************************/

void GetDepthBuffer(	int amount, int offset, 	ZASM Instruction: 
			int stride, int *ptr )		GETDEPTHB
			
Opcode: OGetDepthBufferRegister();
Example use:

/************************************************************************************************************/

////////////////////
/// Modify Tiles ///
////////////////////


void CopyTile(int srctile, int desttile);		ZASM Instruction:
							COPYTILERR d2,d3
							COPYTILEVV
							COPYTILERV
							COPYTILEVR
/**
* Copies the tile specified by scrtile onto the tile space
* specified by desttile. The valid tile value range is 0 to 65519.
* This change is permanent / temporary (!check!) within the quest file
* and will / not (!check!) be retained when saving the game.
*
*/ Example Use:

	CopyTile(312,11614);
	Copies tile 312, to tile 11614. Tiles 312, and 11614 will be identical.

/** TIP **
* CopyTile may be used to change Link's tile, by copying a tile onto whatever tile ZC is
* using as a source for Link->Tile
* Thus, although you cannot write directly to Link->Tile, you can write to the actual tile 
* that is being used for this Link attribute, and you can do this for any other game graphic
* that you need to change. 
*
* When doing this, it is important to read Link->Dir or Link->Flip, *after* Waitdraw() and 
* perform the CopyTile() operation immediately thereafter. 
*/

/************************************************************************************************************/
 
void SwapTile(int firsttile, int secondtile);		ZASM Instruction:
							SWAPTILERR d2,d3
							SWAPTILEVV
							SWAPTILEVR
							SWAPTILERV
/**
* Swaps the two tiles specified by firsttile and secondtile.  
* The valid tile value range is 0 to 65519.
* This change is *TEMPORARY* within the quest file
* and will not be retained when saving the game.
*
*/ Example Use:

SwapTile(312,11614);
Changes tile 11614 into tile 312; and tile 312 into tile 11614, transposing their positions.

/************************************************************************************************************/

void ClearTile(int tileref);			ZASM Instruction:
						CLEARTILER <d3>
						CLEARTILEV
/**
* Erases the tile specified by tileref.
* This change is temporary within the quest file
* and will not be retained when saving the game.
* Tiles are not / are  (!check!) shifted upward to adjust for the cleared tile. 
*
*/ Example Use:

	ClearTile(21362);
	Clears tile 21362 by ( blanking it to colour 0 ) | ( removing it and shifting all tiles 
	thereafter upward ).

/************************************************************************************************************/

//Overlay Tile

//! Is there a ZScript equivalent of this?!
//! This instruction seems to be ***ZASM-specific***.
//! Game->overlayTile() and Screen->OverlayTile() both return an error (no such pointer).
//! Add this to the bytecode in a future build. 

void OverlayTile() ?

    OVERLAYTILEVV
    OVERLAYTILEVR
    OVERLAYTILERV
    OVERLAYTILERR

/************************************************************************************************************/

///////////////
/// Tracing ///
///////////////


void Trace(float val);		ZASM Instruction: 
				TRACER d3
				TRACEV
/**
* Prints a line containing a string representation of val to allegro.log.
* Useful for debugging scripts. You may trace int, and float types. 
* For b oolean values, see TraceB() below.
* Values printed to allegro.log no not incorporate any spacing, or carriage
* returns. You must manually add these into your commands. 
* Int values are not truncated when printed, and will always have four leading 
* zeros after the decimal point. 
* To add new lines (carriange returns), see TraceNL() below. 
*
*/ Example Use:

	int val = 4;
	Trace(val);
	Prints 4.000 to allegro.log

/************************************************************************************************************/

void TraceB(bool state);	ZASM Instruction: 
				TRACE2R d3
				TRACE2V
/**
* Prints a boolean state to allegro.log. Works as trace() above, but prints 'true'
* or 'false' to allegro.log
*
*/ Example Use:

	bool test = true;
	TraceB(test);
	Prints 'true' to allegro.log.

/************************************************************************************************************/

void TraceToBase(	int val, int base, 	ZASM Instruction:
			int mindigits	);	TRACE3
/**
* Prints a line in allegro.log representing 'val' in numerical base 'base',
* where 2 <= base <= 36, with minimum digits 'mindigits'.
* (Base must be at least base-2, and at most, base-36)
* Can be useful for checking hex values or flags ORed together, or just to trace
* an integer value, as Trace() always traces to four decimal places.
* mindigits specifies the minimum number of integer digits to print.
* Unlike Trace(), Decimal values are not printed. TraceToBase *does not* handle floats.
* If you specify a floating point value as arg 'val', it will be Floored before conversion.
*
*/ Example Use:

	TraceToBase(20,8,1);
	Converts (decimal) d20 to base-8 (o24 in base-8) and prints value '024' to allegro.log

	TraceToBase(50,16,1);
	Converts (decimal) d50 to base-16 (0x32 hexadecimal) and prints value '0x32' to allegro.log.

/************************************************************************************************************/

void ClearTrace();		ZASM Instruction:
				TRACE4
/**
* Clears allegro.log of all current traces and messages from Zelda Classic/ZQuest.
* Works on a per-quest, per-session basis. Values recorded from previous sessions are not erased.
*
*/ Example Use

	ClearTrace();

/************************************************************************************************************/

void TraceNL();		ZASM Instruction:
			TRACE5
/**
* Traces a newline to allegro.log
* This inserts a carriage return (as if pressing return/enter) into allegro.log
* and is useful for providing formatting to debugging. 
*
*/ Example Use:

	TraceNL();
	Prints a carriage return to allegro.log.

/************************************************************************************************************/

void TraceS(int s[]);		ZASM Instruction:
				TRACE6 d3
/**
* Works as Trace() above, but prints a full string to allegro.log, using the array pointer
* (name) as its argument.
* Maximum 512 characters. Functions from string.zh can be used to split larger strings.
*
*/ Example Use:

	int testString[]="This is a string.";
	TraceS(testString);
	Prints 'This is a string.' to allegro.log. 

/************************************************************************************************************/

///////////////////////
/// Array Functions ///
///////////////////////


int SizeOfArray(int array[]);		ZASM Instruction:
					ARRAYSIZE d2
/**
* Returns the index size of the array pointed by 'array'.
* Works only on int, and float type arrays. Boolean arrays are not supported.
* Useful in for loops. 
*
*/ Example Use:

	int isAnArray[216];
	int x;
	x = SizeOfArray(isAnArray);
	The value of x becomes 216.

/************************************************************************************************************/

////////////////////////
/// Operator Symbols ///
////////////////////////

Name		Sign	ZASM (R)	ZASM (V)	Definition
PLUS		+ 	ADDR<><>	ADDV<><>	Adds a value a + b, a + 3
MINUS		-  	SUBR<><>	SUBV<><>	Subtracts a value a - b, a - 2
INCREMENT	++  					Increments a value by '1'
DECREMENT	--  					Decreases a value by '1'
MULTIPLY	*  	MULTR<><>	MULTV<><>	Multiplies values a * b
DIVIDE		/  	DIVR<><>	DIVV<><>	Divides values a / b
MODULUS		%  					Returns the remainder of integer division of 4 % 2
NOT		!  	NOT<>				Inverse logic boolean operator. 
							if ( !var1 == 0 ) returns true if var1 is zero, 
							and false if var1 is non-zero
EQUALS		=  	SETR<><>	SETV<><>	Sets a value to another value a = 4
EXACTLY EQUALS	==  					Compares value a == b and returns if they match.
NOT EQUALS	!=  					Compares values a != b and returns if they do not match,
LESSTHAN	<  					Comapres a < b and returns if a is less then b.
MORETHAN	>  					Compares a > b and returns if a is more than b.
LOGICAL OR	||  					Boolean logic, Or.
LOGICAL AND	&&  					Boolean Logic And.

SET ADDRESS ARG		SETA1<><>
			SETA2<><>
GET ADDRESS ARG		GETA1<><>
			GETA2<><>

Note: LOGICAL XOR (^^) is not valid in ZScript, but you may simulate it with custom functions. 

///////////////////////////////////////
/// Misc ZASM-Specific Instructions ///
///////////////////////////////////////

GOTO<><>
GOTOTRUE<><>
GOTOFALSE<><>
GOTOLESS<><>
GOTOMORE<><>
POP<>
PUSHR<>
PUSHV<>
ENQUEUER<><>
ENQUEUEV<><>
DEQUEUE<>
GOTOR<>
LOADI<><>
STOREI<><>
LOOP<><>
MODR<><>
MODV<><>
CHECKTRIG
COMPOUNDR<>
COMPOUNDV<>
FLIPROTTILEVV<><>
FLIPROTTILERR<><>
FLIPROTTILERV<><>
FLIPROTTILEVR<><>

/* These may not be implemented. 
	GETTILEPIXELV<>
	GETTILEPIXELR<>
	SETTILEPIXELV<>
	SETTILEPIXELC<>
	
	SHIFTTILEVV<><>
	SHIFTTILEVR<><>
	SHIFTTILERR<><>
	SHIFTTILERV<><>
*/ 


/* Handles array data allocation.
	ALLOCATEMEMR<><>
	ALLOCATEMEMV<><>
	ALLOCATEMGEMR<><>
	ALLOCATEMGEMV<><>
*/

/************************************************************************************************************/

/////////////////////////
/// Bitwise Operators ///
/////////////////////////

Nor	ZScript Symbol		ZASM Instructions:
				NORR<><>
				NORV<><>
				
Xor 	ZScript Symbol		ZASM Instructions:
	^			XORV<><>
				XORR<><>

XNor	ZScript Symbol		ZASM Instructions:
				XNORV<><>
				XNORV<><>

Nand	ZScript Symbol		ZASM Instructions:
				NANDV<><>
				NANDR<><>
				
Or	ZScript Symbol		ZASM Instructions:
				ORV<><>
				ORR<><>
DANDR

Left Shift <<			LSHIFTV<><>
				LSHIFTR<><>

Right Shift >>			RSHIFTV<><>
				RSHIFTR<><>
				
Not				BITNOT<>
				
/************************************************************************************************************/

//////////////////////////////
/// Mathematical Functions ///
//////////////////////////////

int Rand(int maxvalue);		ZASM Instruction:
				RNDR<><> d2,d3
				RNDV<><>

/**
* Computes and returns a random integer between 0 and maxvalue,
* or a negative value between maxvalue and 0 if maxvalue is negative.
*
*/ Example Use:

	Rand(40);
	Produces a random number between 0 and 40.

/************************************************************************************************************/

float Sin(float deg);		ZASM Instruction:
				SINR<><> d2,d3
				SINV<><>

/**
* Returns the trigonometric sine of the parameter, which is interpreted
* as a degree value.
*
*/ Example Use:

	float x = Sin(32);
	x = 0.5299

/************************************************************************************************************/

float Cos(float deg);		ZASM Instruction: 
				COSR<><> d2,d3
				COSV<><>

/**
* Returns the trigonometric cosine of the parameter, which is
* interpreted as a degree value.
*
*/ Example Usage:

	float x = Cos(40);
	x = 0.7660

/************************************************************************************************************/

float Tan(float deg);		ZASM Instruction:
				TANR<><> d2,d3
				TANV<><>

/**
* Returns the trigonometric tangent of the parameter, which is
* interpreted as a degree value. The return value is undefined if
* deg is of the form 90 + 180n for an integral value of n.
*
*/ Example Use:

	float x = Tan(100);
	x = -5.6712

/************************************************************************************************************/

//!Sources: OMultImmediate, OArcSinRegister
//Is there a direct ZASM instruction equivalent, or does this function run as a routine?

float RadianSin(float rad);
/**
* Returns the trigonometric sine of the parameter, which is interpreted
* as a radian value.
*
*/ Example Use:

/************************************************************************************************************/

//!Sources: OMultImmediate, OCosRegister
//Is there a direct ZASM instruction equivalent, or does this function run as a routine?

float RadianCos(float rad);
/**
* Returns the trigonometric cosine of the parameter, which is
* interpreted as a radian value.
*
*/ Example Use:

/************************************************************************************************************/

//!Sources: OMultImmediate, OTanRegister
//Is there a direct ZASM instruction equivalent, or does this function run as a routine?

float RadianTan(float rad);
/**
* Returns the trigonometric tangent of the parameter, which is
* interpreted as a radian value. The return value is undefined for
* values of rad near (pi/2) + n*pi, for n an integer.
*
*/ Example Use:

/************************************************************************************************************/

float ArcTan(int x, int y);		ZASM Instruction:
					ARCTANR<>
					(Does ARCTANV exist?)
/**
* Returns the trigonometric arctangent of the coordinates, which is
* interpreted as a radian value.
*
*/ Example Use:

/************************************************************************************************************/

float ArcSin(float x);			ZASM Instruction:
					ARCSINR<><>
					ARCSINV<><> (Can't find this in the source code)
							ffasm.cpp line 217
/**
* Returns the trigonometric arcsine of x, which is
* interpreted as a radian value.
*
*/ Example Use:

/************************************************************************************************************/

float ArcCos(float x);		ZASM Instruction:
				ARCCOSR<><>
				ARCCOSV<><>

/**
* Returns the trigonometric arccosine of x, which is
* interpreted as a radian value.
*
*/ Example Use:

/************************************************************************************************************/

float Max(float a, float b);	ZASM Instruction:
				MAXR<><>
				MAXV<><>
/**
* Returns the greater of a and b.
*
*/ Example Use:

/************************************************************************************************************/

float Min(float a, float b);	ZASM Instriction:
				MINR<><>
				MINV<><>
/**
* Returns the lesser of a and b.
*
*/ Example Use:

/************************************************************************************************************/

int Pow(int base, int exp);	ZASM Instruction:
				POWERR<><>
				POWERV<><>
/**
* Returns base^exp. The return value is undefined for base=exp=0. Note
* also negative values of exp may not be useful, as the return value is
* truncated to the nearest integer.
*
*/ Example Use:

/************************************************************************************************************/

int InvPow(int base, int exp);		ZASM Instruction:
					IPOWERR<><>
					IPOWERV<><>
/**
* Returns base^(1/exp). The return value is undefined for exp=0, or
* if exp is even and base is negative. Note also that negative values
* of exp may not be useful, as the return value is truncated to the
* nearest integer.
*
*/ Example Use:

/************************************************************************************************************/

float Log10(float val);			ZASM Instruction:
					LOG10<>
/**
* Returns the log of val to the base 10. Any value <= 0 will return 0.
*
*/ Example Use:

/************************************************************************************************************/

float Ln(float val);			ZASM Instruction:
					LOGE<>

/**
* Returns the natural logarithm of val (to the base e). Any value <= 0 will return 0.
*
*/ Example Use:

/************************************************************************************************************/

int Factorial(int val);			ZASM Instruction:
					FACTORIAL<>
/**
* Returns val!. val < 0 returns 0.
*
*/ Example Use:

/************************************************************************************************************/

float Abs(float val);			ZASM Instruction:
					ABS<>
/**
* Return the absolute value of the parameter, if possible. If the
* absolute value would overflow the parameter, the return value is
* undefined.
*
*/ Example Use:

/************************************************************************************************************/

float Sqrt(float val);			ZASM Instruction:
					SQROOTV<><>
					SQROOTR<><>
/**
* Computes the square root of the parameter. The return value is
* undefined for val < 0.
* NOTE: Passing negative values to Sqrt() will return an error. See SafeSqrt() in std.zh
*/ Example Use:

	int x = Sqrt(16);
	x = 4

/************************************************************************************************************/
/************************************************************************************************************/



//===================================
//--- FFC Functions and Variables ---
//===================================

class ffc
{

/*
*	The following functions, and arrays are part of the ffc class.
*
*	Ordinarily, these are set when writing an ffc script, using the pointer
*		this->
*	Example: this->Data = 10;	Sets the Data variable for the present ffc
*					to a value of '10'.
*
*	The 'this->' pointer is used in ffcs, and item scripts only. It references ffc
*	variables and arrays in an ffc script; and itemdata variables in an item script.
*
*	Changing ffc variables without 'this->': 
*
*	You may change a variable, or array value of the ffc class by loading the ffc into a custom pointer
*	using Screen->LoadFFC(int number) as follows:
*	
*	ffc f; //Declare a general ffc pointer. 
*		//You must use the ffc token to declare the pointer, but you may use any 
*		//name that you desire for it. 'f' here, is merely a short-name example. 
*
*	f = Screen->LoadFFC(10); //Loads the data of ffc ID 10 for the present screen into the 'f' pointer.
*
* 	f->Data = 15; //Sets the 'Data' variable of the ffc to a value of '15'.
*
*	f->X = 120; //Sets  the X-position of the ffc assigned to pointer 'f' to a value of '120'.
*/ 


Set Working FFC ID: 		ZASM Instruction
				REFFFC
				
/************************************************************************************************************/


int Data;			ZASM Instruction: 
				DATA<d3>
				
/**
* The number of the combo associated with this FFC.
*/ Example Use:

	f->Data = 10;
	Sets the ffc to Combo 10.
	
/************************************************************************************************************/

int Script;			ZASM Instruction: 
				FFSCRIPT<d3>
				
/**
* The number of the script assigned to the FFC. This will be automatically
* set to 0 when the FFC's script halts. A script cannot change the script of
* the FFC running it; in other words, f->Script is read-only when f==this.
* When an FFC's script is changed, its arguments, Misc[], and registers will
* all be set to 0, and it will start running from the beginning. Set
* ffc->InitD[] after setting the script before the script starts running
* to pass arguments to it.
*
*/ Example Use:

	f->Script = 10;
	Sets the ffc to Combo 10.
	
/************************************************************************************************************/
	
int CSet;			ZASM Instruction: 
				FCSET<d3>
				
/**
* The cset of the FFC.
*
*/ Example Use:

	f->CSet = 2;
	Sets the ffc to CSet 2.	
	
/************************************************************************************************************/

int Delay;			ZASM Instruction: 
				DELAY<d3>
				
/**
* The FFC's animation delay, in frames.
*
*/ Example Use:

	f->Delay = 120;
	120 frames will pass before the ffc animates. 

/************************************************************************************************************/
	
int X;			ZASM Instruction: 
				FX<d3>
				
/**
* The FFC's X position on the screen.
*
* Values outside the screen boundaries *are* legal. 
*
*/ Example Use:

	f->X = 43;
	Sets the ffc at X-position 43; 43 pixels to the right of the leftmost screen edge.
		
/************************************************************************************************************/

int Y;			ZASM Instruction: 
				FY<d3>
				
/**
* The FFC's Y position on the screen.
*
* Values outside the screen boundaries *are* legal. 
* The Y value 0 is automatically offset to account for the passive subscreen. 
* To place an ffc in the area of the passive subscreen, a negative value must be passed to Y. 
*
*/ Example Use:

	f->X = 90;
	Sets the ffc at Y-position to 90; i.e. 90 pixels below the passive subscreen.

/************************************************************************************************************/

int Vx;			ZASM Instruction: 
				XD<d3>
				
/**
* The FFC's velocity's X-component.
*
*
*/ Example Use:

	f->Vx = 20;
	The ffc will move by 20 pixels per second on the X avis.
		
/************************************************************************************************************/

int Vy;			ZASM Instruction: 
				YD<d3>
				
/**
* The FFC's velocity's Y-component.
*
*
*/ Example Use:

	f->Vy = 20;
	The ffc will move by 20 pixels per second on the Y avis.
	
/************************************************************************************************************/
	
float Ax;			ZASM Instruction: 
				XD2<d3>
				
/**
* The FFC's acceleration's X-component.
*
*
*/ Example Use:

	f->Vx = 1.03;
	Every frame, the velocity X-component will increase by 1.03. 
		
/************************************************************************************************************/

float Ay;			ZASM Instruction: 
				YD2<d3>
				
/**
* The FFC's acceleration's Y-component.
*
*
*/ Example Use:

	f->Vx = 0.2903;
	Every frame, the velocity Y-component will increase by 0.2903. 	
	
/************************************************************************************************************/
	
bool Flags[];			ZASM Instruction: 
				FLAG<d3>
				FFFLAGSD
				
				
/**
* The FFC's set of flags. Use the FFCF_ constants in std.zh as the
* index to access a particular flag.
*
*/ Example Use: !#!

/************************************************************************************************************/

int TileWidth;			ZASM Instruction: 
				FFTWIDTH<d3>
				WIDTH<>
				
/**
* The number of tile columns composing the FFC.
* The maximum value is '4'.
*
*/ Example Use: !#!

/************************************************************************************************************/

int TileHeight;			ZASM Instruction: 
				FFTHEIGHT<d3>
				HEIGHT<>
				
/**
* The number of tile rows composing the FFC.
* The maximum value is '4'.
*
*/ Example Use: !#!

/************************************************************************************************************/

int EffectWidth;		ZASM Instruction: 
				FFCWIDTH<d3>
				
/**
* The width (in pixels) of the area of effect of the combo associated with the FFC.
* The maximum value is '64'.
*
*/ Example Use: !#!

/************************************************************************************************************/

int EffectHeight;		ZASM Instruction: 
				FFCHEIGHT<d3>
				
/**
* The width (in pixels) of the area of effect of the combo associated with the FFC.
* The maximum value is '64'.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Link;			ZASM Instruction: 
				FFLINK<d3>
				LINK<>
				
/**
* The number of the FFC linked to by this FFC.
*
*/ Example Use: !#!

/************************************************************************************************************/

float InitD[8];			ZASM Instruction: 
				FFINITD<>
				FFINITDD<>?
				D<>
				
/**
* The original values of the FFC's 8 D input values as they are stored in
* the .qst file, regardless of whether they have been modified by ZScript.
*
*/ Example Use: !#!

/************************************************************************************************************/

float Misc[16];			ZASM Instruction: 
				FFMISC
				FFMISCD
				
/**
* An array of 16 miscellaneous variables for you to use as you please.
* These variables are not saved with the ffc.
*
*/ Example Use: !#!

/************************************************************************************************************/

Address Argument		ZASM Instruction
				A<>

}; //ffc

/************************************************************************************************************/
/************************************************************************************************************/





//====================================
//--- Link Functions and Variables ---
//====================================



namespace Link
{

//Unimplemented?
Invincibility: LINKINVINC<>

int X;				ZASM Instruction: 
				LINKX
				
/**
* Link's X position on the screen, in pixels. Float values passed to this will be truncated to ints.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Y;				ZASM Instruction: 
				LINKY
				
/**
* Link's Y position on the screen, in pixels. Float values passed to this will be truncated to ints.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Z;				ZASM Instruction: 
				LINKZ
				
/**
* Link's Z position on the screen, in pixels. Float values passed to this will be truncated to ints.
*
*/ Example Use: !#!

/************************************************************************************************************/

bool Invisible;			ZASM Instruction: 
				LINKINVIS
				
/**
* Whether Link is currently being draw to the screen. Set true to remove him from view.
*
*/ Example Use: !#!

/************************************************************************************************************/

bool CollDetection;		ZASM Instruction: 
				LINKINVINC
				
/**
* If true, Link's collision detection with npcs and eweapons is currently turned off.
* This variable works on a different system to clocks and the level 4 cheat, so it will not
* necessarily return true if they are set.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Jump;			ZASM Instruction: 
				LINKJUMP
				
/**
* Link's upward velocity, in pixels. If negative, Link will fall.
* The downward acceleration of Gravity (in Init Data) modifies this value every frame.
*
* This value is intended to be in pixels, but appears to be in tiles. ?!
*
*/ Example Use: !#!

/************************************************************************************************************/

int SwordJinx;			ZASM Instruction: 
				LINKSWORDJINX
				
/**
* The time, in frames, until Link regains use of his sword. -1 signifies
* a permanent loss of the sword caused by a Red Bubble.
*
*/ Example Use: !#!

/************************************************************************************************************/

int ItemJinx;			ZASM Instruction: 
				LINKITEMJINX
				
/**
* The time, in frames, until Link regains use of his items. -1 signifies
* a permanent loss of his items. caused by a Red Bubble.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Drunk;			ZASM Instruction: 
				LINKDRUNK
				
/**
* The time, in frames, that Link will be 'drunk'. If positive, the player's
* controls are randomly interfered with, causing Link to move erratically.
* This value is decremented once per frame. As the value of Drunk approaches 0,
* the intensity of the effect decreases.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Dir;			ZASM Instruction: 
				LINKDIR
				
/**
* The direction Link is facing. Use the DIR_ constants in std.zh to set
* or compare this variable. Note: even though Link can move diagonally if the
* quest allows it, his sprite doesn't ever use any of the diagonal directions,
* which are intended for enemies only.
*
* Reading this value occurs after Waitdraw(). 
*
*/ Example Use: !#!

/************************************************************************************************************/

int HitDir;			ZASM Instruction: 
				LINKHITDIR
				
/**
* The direction Link should bounce in when he is hit. This is mostly useful for
* simulating getting hit by setting Link->Action to LA_GOTHURTLAND.
*
* This value does nothing is Link->Action does not equal LA_GOTHURTLAND or LA_GOTHURTWATER.
* Forcing this value to -1 prevent Link from being knocked back when injured, or when touching any enemy. 
*
*/ Example Use: !#!

/************************************************************************************************************/

int HP;				ZASM Instruction: 
				LINKHP
				
/**
* Link's current hitpoints, in 16ths of a heart.
*
*/ Example Use: !#!

/************************************************************************************************************/

int HP;				ZASM Instruction: 
				LINKMP
				
/**
* Link's current amount of magic, in 32nds of a magic block.
*
*/ Example Use: !#!

/************************************************************************************************************/

int MaxHP;				ZASM Instruction: 
					LINKMAXHP
				
/**
* Link's maximum hitpoints, in 16ths of a heart.
*
*/ Example Use: !#!

/************************************************************************************************************/

int MaxMP;				ZASM Instruction: 
					LINKMAXMP
				
/**
* Link's maximum amount of magic, in 32nds of a magic block.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Action;				ZASM Instruction: 
					LINKACTION<>
				
/**
* Link's current action. Use the LA_ constants in std.zh to set or
* compare this value. 
* This value is read-write, but some actions are undefined in this 
* version of ZC. The following are known to work:
*
*
*
*The effect of writing to this field is currently
* undefined.
*
*/ Example Use: !#!

/************************************************************************************************************/

int HeldItem;				ZASM Instruction: 
					LINKHELD<>
				
/**
* Link's current action. Use the LA_ constants in std.zh to set or
* The item that Link is currently holding up; reading or setting this
* field is undefined if Link's action is not current a hold action.
* Use the I_ constants in std.zh to specify the item, or -1 to show
* no item. Setting HeldItem to values other than -1 or a valid item
* ID is undefined.
*
*/ Example Use: !#!

/************************************************************************************************************/

int LadderX;				ZASM Instruction: 
					LINKLADDERX
				
/**
* The X position of Link's stepladder, or 0 if no ladder is onscreen.
* This is read-only; while setting it is not syntactically incorrect, it does nothing.
*
*/ Example Use: !#!

/************************************************************************************************************/

int LadderY;				ZASM Instruction: 
					LINKLADDERY
				
/**
* The Y position of Link's stepladder, or 0 if no ladder is onscreen.
* This is read-only; while setting it is not syntactically incorrect, it does nothing.
*
*/ Example Use: !#!

/************************************************************************************************************/



	*** Input Functions ***
	* The following Input* boolean values return true if the player is pressing
	* the corresponding button, analog stick, or key. Writing to this variable simulates
	* the press or release of that referenced button, analog stick, or key.
	*/
	
	bool InputStart;		ZASM: INPUTSTART
	
	bool InputMap;			ZASM: INPUTMAP
	
	bool InputUp;			ZASM: INPUTUP
	
	bool InputDown;			ZASM: INPUTDOWN
	
	bool InputLeft;			ZASM: INPUTLEFT
	
	bool InputRight;		ZASM: INPUTRIGHT
	
	bool InputA;			ZASM: INPUTA
	
	bool InputB;			ZASM: INPUTB
	
	bool InputL;			ZASM: INPUTL
	
	bool InputR;			ZASM: INPUTR
	
	bool InputEx1			ZASM: INPUTEX1
	
	bool InputEx2			ZASM: INPUTEX2
	
	bool InputEx3			ZASM: INPUTEX3
	
	bool InputEx4			ZASM: INPUTEX4
	
	bool InputAxisUp;		ZASM: INPUTAXISUP
	
	bool InputAxisDown;		ZASM: INPUTAXISDOWN
		
	bool InputAxisLeft;		ZASM: INPUTAXISLEFT
	
	bool InputAxisRight;		ZASM: INPUTAXISRIGHT
	
	
	*** Press Functions ***
	/**
	* The following Press* boolean values return true if the player activated
	* the corresponding button, analog stick, or key this frame. Writing to this
	* variable simulates the press or release of that referenced button, analog stick,
	* or keys input press state.
	*/


	bool PressStart;		ZASM: INPUTPRESSSTART
	
	bool PressMap;			ZASM: INPUTPRESSMAP 
	
	bool PressUp;			ZASM: INPUTPRESSUP
	
	bool PressDown;			ZASM: INPUTPRESSDOWN
	
	bool PressLeft;			ZASM: INPUTPRESSLEFT
	
	bool PressRight;		ZASM: INPUTPRESSRIGHT
	
	bool PressA;			ZASM: INPUTPRESSA
	
	bool PressB;			ZASM: INPUTPRESSB
	
	bool PressL;			ZASM: INPUTPRESSL
	
	bool PressR;			ZASM: INPUTPRESSR
	
	bool PressEx1			ZASM: INPUTPRESSEX1
	
	bool PressEx2			ZASM: INPUTPRESSEX2
	
	bool PressEx3			ZASM: INPUTPRESSEX3
	
	bool PressEx4			ZASM: INPUTPRESSEX4
	
	bool PressAxisUp;		ZASM: PRESSAXISUP
	
	bool PressAxisDown;		ZASM: PRESSAXISDOWN
	
	bool PressAxisLeft;		ZASM: PRESSAXISLEFT
	
	bool PressAxisRight;		ZASM: PRESSAXISRIGHT

/************************************************************************************************************/

int InputMouseX;			ZASM Instruction: 
					INPUTMOUSEX
				
/**
* The mouse's in-game X position. This value is undefined if
* the mouse pointer is outside the Zelda Classic window.
*
*/ Example Use: !#!

/************************************************************************************************************/

int InputMouseY;			ZASM Instruction: 
					INPUTMOUSEY
				
/**
* The mouse's in-game Y position. This value is undefined if
* the mouse pointer is outside the Zelda Classic window.
*
*/ Example Use: !#!

/************************************************************************************************************/

int InputMouseB;			ZASM Instruction: 
					INPUTMOUSEB
				
/**
* Whether the left or right mouse buttons are pressed, as two flags OR'd (|) together;
* use the MB_ constants or the Input'X'Click functions in std.zh to check the button states.
* InputMouseB is read only; while setting it is not syntactically incorrect, it does nothing
* If you are not comfortable with binary, you can use the InputMouse'x' functions in std.zh
*
*/ Example Use: !#!

/************************************************************************************************************/

int InputMouseZ;			ZASM Instruction: 
					INPUTMOUSEB
				
/**
* The current state of the mouse's scroll wheel, negative for scrolling down and positive for scrolling up.
*
*/ Example Use: !#!

/************************************************************************************************************/

bool Item[256];				ZASM Instruction: 
					LINKITEMD
				
/**
* True if Link's inventory contains the item whose ID is the index of
* the array access. Use the I_ constants in std.zh as an index into this array.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Equipment;				ZASM Instruction: 
					LINKEQUIP
				
/**
* Contains the item IDs of what is currently equiped to Link's A and B buttons.
* The first 8 bits contain the A button item, and the second 8 bits contain the B button item.
* Currently it is only possible to retrieve this value and not to set it.
* If you are not comfortable with performing binary operations,
* you can use the functions GetEquipmentA() or GetEquipmentB() in std.zh.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Tile;				ZASM Instruction: 
					LINKTILE
				
/**
* The current tile associated with Link. The effect of writing to this variable is undefined.
* Because Link's tile is not determined until he is drawn, this will actually represent
* Link's tile in the previous frame.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int Flip;				ZASM Instruction: 
					LINKFLIP
				
/**
* The current tile associated with Link. The effect of writing to this variable is undefined.
* Because Link's tile is not determined until he is drawn, this will actually represent
* Link's tile flip in the previous frame.
*
*/ Example Use: !#!
	


/************************************************************************************************************/

int HitHeight;
int HitWidth;				ZASM Instruction: 
					LINKHYSZ
					LINKHXSZ
				
/**
*	!#! Verify that HitWidth and HitHeight WORK! They have ZASM instructions. 
*
*/ Example Use: !#!


/************************************************************************************************************/

int HitZHeight;				ZASM Instruction: 
					LINKHZSZ
				
/**
* The Z-axis height of Link's hitbox, or collision rectangle.
* The lower it is, the lower a flying or jumping enemy must fly in order to hit Link.
* Writing to this is ignored unless Extend is set to values >=3.	
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int HitXOffset;				ZASM Instruction: 
					LINKHXOFS
				
/**
* The X offset of Link's hitbox, or collision rectangle.
* Setting it to positive or negative values will move Link's hitbox left or right.
* Writing to this is ignored unless Extend is set to values >=3.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int HitYOffset;				ZASM Instruction: 
					LINKHYOFS
				
/**
* The Y offset of Link's hitbox, or collision rectangle.
* Setting it to positive or negative values will move Link's hitbox up or down.
* Writing to this is ignored unless Extend is set to values >=3.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int DrawXOffset;			ZASM Instruction: 
					LINKXOFS
				
/**
* The X offset of Link's sprite.
* Setting it to positive or negative values will move the sprite's tiles left or right relative to its position.
* Writing to this is ignored unless Extend is set to values >=3.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int DrawYOffset;			ZASM Instruction: 
					LINKYOFS
				
/**
* The Y offset of Link's sprite.
* Setting it to positive or negative values will move the sprite's tiles up or down relative to its position.
* Writing to this is ignored unless Extend is set to values >=3.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int DrawZOffset;			ZASM Instruction: 
					LINKZOFS
				
/**
* The Z offset of Link's sprite.
* Writing to this is ignored unless Extend is set to values >=3.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

float Misc[16];				ZASM Instruction: 
					LINKMISC
					LINKMISCD
				
/**
* An array of 16 miscellaneous variables for you to use as you please.
* These variables are not saved with Link.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

void Warp(int DMap, int screen);	ZASM Instruction: 
					WARP
					WARPR
				
/**
* Warps link to the given screen in the given DMap, just like if he'd
* triggered an 'Insta-Warp'-type warp.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

void PitWarp(int DMap, int screen);	ZASM Instruction: 
					PITWARP
					PITWARPR
				
/**
* This is identical to Warp, but Link's X and Y positions are preserved
* when he enters the destination screen, rather than being set to the
* Warp Return square.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

SelectAWeapon(int dir);			ZASM Instruction: 
					!#!
				
/**
* Sets the A button item to the next one in the given direction based on
* the indices set in the subscreen. This will skip over items if A and B
* would be set to the same item.
* If the quest rule "Can Select A-Button Weapon On Subscreen" is disabled,
* this function does nothing.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

SelectBWeapon(int dir);			ZASM Instruction: 
					!#!
				
/**
* Sets the B button item to the next one in the given direction based on
* the indices set in the subscreen. This will skip over items if A and B
* would be set to the same item.
*
*/ Example Use: !#!
	
/************************************************************************************************************/
	
}; //Link

/************************************************************************************************************/
/************************************************************************************************************/


//======================================
//--- Screen Functions and Variables ---
//======================================

namespace Screen
{

float D[];				ZASM Instruction: 
					SD
					SDD
					SDDD
					SDDDD
				
/**
* Each screen has 8 general purpose registers for use by script
* programmers. These values are recorded in the save file when the
* player saves their game. Do with these as you will.
* Note that these registers are tied to screen/DMap combinations.
* Encountering the same screen in a different DMap will result in a
* different D[] array.
*
* Values in Screen->D are preserved through game saving.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int Flags[];				ZASM Instruction: 
					SCREENFLAGSD
					SCREENFLAGS
				
/**
* An array of ten integers containing the states of the flags in the
* 10 categories on the Screen Data tabs 1 and 2. Each flag is ORed into the
* Flags[x] value, starting with the top flag as the smallest bit.
* Use the SF_ constants as the array acces for this value, and the
* GetScreenFlags function if you are not comfortable with binary.
* This is read-only; while setting it is not syntactically incorrect, it does nothing.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int EFlags[];				ZASM Instruction: 
					SCREENEFLAGSD
					SCREENEFLAGS
				
/**
* An array of 3 integers containing the states of the flags in the
* E.Flags tab of the Screen Data dialog. Each flag is ORed into the
* EFlags[x] value, starting with the top flag as the smallest bit.
* Use the SEF_ constants as the array acces for this value, and the
* GetScreenEFlags function if you are not comfortable with binary.
* This is read-only; while setting it is not syntactically incorrect, it does nothing.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int ComboD[];				ZASM Instruction: 
					CD###		COMBOD	
					COMBODD		COMBODDM
					COMBODDM	COMBOSD
					
/**
* The combo ID of the ith combo on the screen, where i is the index
* used to access this array. Combos are counted left to right, top to
* bottom.
* Screen dimensions are 16 combos wide, by 11 combos high. 
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int ComboC[];				ZASM Instruction: 
					CC###		COMBOC
					COMBOCD		COMBOCDM
					
/**
* The CSet of the tile used by the ith combo on the screen, where i is
* the index used to access this array. Combos are counted left to right,
* top to bottom.
* Screen dimensions are 16 combos wide, by 11 combos high. 
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int ComboF[];				ZASM Instruction: 
					CF###		COMBOF
					COMBOFD		COMBOFDM
					
/**
* The placed flag of the ith combo on the screen, where i is the index
* used to access this array. Combos are counted left to right, top to
* bottom. Use the CF_ constants in std.zh to set or compare these values.
* Screen dimensions are 16 combos wide, by 11 combos high. 
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int ComboI[];				ZASM Instruction: 
					CI###		COMBOID
							COMBOIDM

					
/**
* The inherent flag of the ith combo on the screen, where i is the index
* used to access this array. Combos are counted left to right, top to
* bottom. Use the CF_ constants in std.zh to set or compare these values.
* Screen dimensions are 16 combos wide, by 11 combos high. 
*
*/ Example Use: !#!
	
/************************************************************************************************************/
	
int ComboT[];				ZASM Instruction: 
					CT###		COMBOTD
							COMBOTDM

					
/**
* The combo type of the ith combo on the screen, where i is the index
* used to access this array. Combos are counted left to right, top to
* bottom. Use the CT_ constants in std.zh to set or compare these values.
* Screen dimensions are 16 combos wide, by 11 combos high. 
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int ComboS[];				ZASM Instruction: 
					CS###		COMBOSD
							COMBOSDM

					
/**
* The walkability mask of the ith combo on the screen, where i is the
* index used to access this array. Combos are counted left to right, top
* to bottom. The least signficant bit is true if the top-left of the combo
* is solid, the second-least signficant bit is true if the bottom-left
* of the combo is is solid, the third-least significant bit is true if the
* top-right of the combo is solid, and the fourth-least significant bit is
* true if the bottom-right of the combo is solid.
* Screen dimensions are 16 combos wide, by 11 combos high.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int MovingBlockX;			ZASM Instruction: 
					PUSHBLOCKX

					
/**
* The X position of the current moving block. If there is no moving block
* on the screen, it will be -1. This is read-only; while setting it is not
* syntactically incorrect, it does nothing.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int MovingBlockY;			ZASM Instruction: 
					PUSHBLOCKY
					
/**
* The Y position of the current moving block. If there is no moving block
* on the screen, it will be -1. This is read-only; while setting it is not
* syntactically incorrect, it does nothing.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int MovingBlockCombo;			ZASM Instruction: 
					PUSHBLOCKCOMBO

/**
* The combo used by moving block. If there is no block moving, the value
* is undefined.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int MovingBlockCSet;			ZASM Instruction: 
					PUSHBLOCKCSET

/**
* The CSet used by moving block. If there is no block moving, the value
* is undefined.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int UnderCombo;				ZASM Instruction: 
					UNDERCOMBO

/**
* The current screen's under combo. 
* !#! Is setting this legal?
*
*/ Example Use: !#!
	
/************************************************************************************************************/
	
int UnderCSet;				ZASM Instruction: 
					UNDERCSET

/**
* The current screen's under CSet.
* !#! Is setting this legal?
*
*/ Example Use: !#!
	
/************************************************************************************************************/
	
bool State[];				ZASM Instruction: 
					SCREENSTATED
					SCREENSTATEDD

/**
* An array of miscellaneous status data associated with the current
* screen.
* Screen states involve such things as permanent screen secrets, the
* status of lock blocks and treasure chest combos, and whether items have
* been collected.
* These values are recorded in the save file when the player saves their
* game. Use the ST_ constants in std.zh as indices into this array.
*
*/ Example Use: !#!
	
/************************************************************************************************************/

int Door[];				ZASM Instruction: 
					SCRDOORD
					SCRDOOR

/**
* The door type for each of the four doors on a screen. Doors are counted
* using the first four DIR_ constants in std.zh. Use the D_ constants in
* std.zh to compare these values.
*
*/ Example Use: !#!
	
/************************************************************************************************************/
	
int RoomType;				ZASM Instruction: 
					ROOMTYPE

/**
* The type of room this screen is (Special Item, Bomb Upgrade, etc)
* This is currently read-only.
* Use the RT_* constants in std.zh
*
*/ Example Use: !#!
	
/************************************************************************************************************/
	
int RoomData;				ZASM Instruction: 
					ROOMDATA

/**
* This is the data associated with the room type above. What it means depends
* on the room type. For Special Item, it will be the item ID, for a Shop, it
* will be the Shop Number, etc.
* Basically, this is what's in the "Catch-all" menu item underneath Room Type.
* If the room type has no data (eg, Ganon's room), this will be undefined.
*
*/ Example Use: !#!
	
/************************************************************************************************************/
	
void TriggerSecrets();			ZASM Instruction: 
					SECRETS ? !#!

/**
* Triggers screen secrets temporarily. Set Screen->State[ST_SECRET]
* to true beforehand or afterward if you would like them to remain
* permanent.
*
*/ Example Use: Screen->TriggerSecrets();

	
/************************************************************************************************************/
	
bool Lit;				ZASM Instruction: 
					LIT

/**
* Whether or not the screen is lit. Setting this variable will change the
* lighting setting of the screen until you change screens.
*
*/ Example Use: !#!

	
/************************************************************************************************************/

int Wavy;				ZASM Instruction: 
					WAVY

/**
* The time, in frames, that the 'wave' screen effect will be in effect.
* This value is decremented once per frame. As the value of Wavy approaches 0,
* the intensity of the waves decreases.
*
*/ Example Use: !#!

/************************************************************************************************************/

int Quake;				ZASM Instruction: 
					QUAKE

/**
* The time, in frames, that the screen will shake. This value is decremented
* once per frame. As the value of Quake approaches 0, the intensity of the
* screen shaking decreases.
*
*/ Example Use: !#!

/************************************************************************************************************/

void SetSideWarp(int warp, int screen, int dmap, int type);		ZASM Instruction: 
									SETSIDEWARP

/**
* Sets the current screen's side warp 'warp' to the destination screen,
* DMap and type. If any of the parameters screen, dmap or type are equal
* to -1, they will remain unchanged. If warp is not between 0 and 3, the
* function does nothing.

* Directions match DIR_* in std_constants.zh
*
*/ Example Use: !#!

/************************************************************************************************************/
	
void SetTileWarp(int warp, int screen, int dmap, int type);		ZASM Instruction: 
									SETTILEWARP

/**
* Sets the current screen's tile warp 'warp' to the destination screen,
* DMap and type. If any of the parameters screen, dmap or type are equal
* to -1, they will remain unchanged. If warp is not between 0 and 3, the
* function does nothing
*
* Warp-Tiles A, B, C, and D are 0, 1, 2, and 3 respectively.
*
*/ Example Use: !#!

/************************************************************************************************************/

int GetSideWarpDMap(int warp);			ZASM Instruction: 
						GETSIDEWARPDMAP

/**
* Returns the destination DMap of the given side warp on the current screen.
* Returns -1 if warp is not between 0 and 3.
*
* Side-Warp Directions match DIR_* in std_constants.zh 
*
*/ Example Use: !#!

/************************************************************************************************************/

int GetSideWarpScreen(int warp);		ZASM Instruction: 
						GETSIDEWARPSCR

/**
* Returns the destination screen of the given side warp on the current
* screen. Returns -1 if warp is not between 0 and 3.
*
* Directions match DIR_* in std_constants.zh
*
*/ Example Use: !#!

/************************************************************************************************************/

int GetSideWarpType(int warp);			ZASM Instruction: 
						GETSIDEWARPTYPE

/**
* Returns the warp type of the given side warp on the current screen.
* Returns -1 if warp is not between 0 and 3.
*
* Directions match DIR_* in std_constants.zh
*
*/ Example Use: !#!

/************************************************************************************************************/

int GetTileWarpDMap(int warp);			ZASM Instruction: 
						GETTILEWARPDMAP

/**
* Returns the destination DMap of the given tile warp on the current screen.
* Returns -1 if warp is not between 0 and 3.
*
* Warp-Tiles A, B, C, and D are 0, 1, 2, and 3 respectively.
*
*/ Example Use: !#!

/************************************************************************************************************/

int GetTileWarpScreen(int warp);		ZASM Instruction: 
						GETTILEWARPSCR

/**
* Returns the destination screen of the given tile warp on the current
* screen. Returns -1 if warp is not between 0 and 3.
*
* Warp-Tiles A, B, C, and D are 0, 1, 2, and 3 respectively.
*
*/ Example Use: !#!

/************************************************************************************************************/

int GetTileWarpType(int warp);			ZASM Instruction: 
						GETTILEWARPTYPE

/**
* Returns the warp type of the given tile warp on the current screen.
* Returns -1 if warp is not between 0 and 3.
*
* Warp-Tiles A, B, C, and D are 0, 1, 2, and 3 respectively.
*
*/ Example Use: !#!

/************************************************************************************************************/

int LayerMap(int n);			ZASM Instruction: 
					LAYERMAP

/**
* Returns the map of the screen currently being used as the nth layer.
* Values of n less than 1 or greater than 6, or layers that are not set up,
* returns -1.
*
*/ Example Use: !#!

/************************************************************************************************************/

int LayerScreen(int n);			ZASM Instruction: 
					LAYERSCREEN

/**
* Returns the number of the screen currently being used as the nth layer.
* Values of n less than 1 or greater than 6, or layers that are not set up,
* returns -1.
*
*/ Example Use: !#!

/************************************************************************************************************/

int NumItems();				ZASM Instruction: 
					ITEMCOUNT

/**
* Returns the number of items currently present on the screen. Screen
* items, shop items, and items dropped by enemies are counted; Link's
* weapons, such as lit bombs, or enemy weapons are not counted.
* Note that this value is only correct up until the next call to
* Waitframe().
*
*/ Example Use: !#!

/************************************************************************************************************/

item LoadItem(int num);			ZASM Instruction: 
					LOADITEMR
					LOADITEMV

/**
* Returns a pointer to the numth item on the current screen. The return
* value is undefined unless 1 <= num <= NumItems().
*
* Attempting to return an invalid item pointer will print an error to allegro.log. 
*
*/ Example Use: !#!

/************************************************************************************************************/

item CreateItem(int id);		ZASM Instruction: 
					CREATEITEMV
					CREATEITEMR

/**
* Returns a pointer to the numth FFC on the current screen. The return
* value is undefined unless 1 <= num <= ffcs, where ffcs is the number
* of FFCs active on the screen.
*
*/ Example Use: !#!

/************************************************************************************************************/

ffc LoadFFC(int num);			ZASM Instruction: 
					GETFFCSCRIPT

/**
* Returns a pointer to the numth FFC on the current screen. The return
* value is undefined unless 1 <= num <= ffcs, where ffcs is the number
* of FFCs active on the screen.
*
*/ Example Use: !#!

/************************************************************************************************************/

int NumNPCs();				ZASM Instruction: 
					NPCCOUNT

/**
* Returns the number of NPCs (enemies and guys) on the screen.
* Note that this value is only correct up until the next call to
* Waitframe().
*
*/ Example Use: !#!

/************************************************************************************************************/

npc LoadNPC(int num);			ZASM Instruction: 
					LOADNPCR
					LOADNPCV

/**
* Returns a pointer to the numth NPC on the current screen. The return
* value is undefined unless 1 <= num <= NumNPCs().
*
*/ Example Use: !#!

/************************************************************************************************************/
	
npc CreateNPC(int id);			ZASM Instruction: 
					CREATENPCR
					CREATENPCV

/**
* Creates an npc of the given type at (0,0). Use the NPC_ constants in
* std.zh to pass into this method. The return value is a pointer to the
* new NPC.
* The maximum number of NPCs on any given screen is 255. ZC will report an
* error to allegro.log if you try to create NPCs after reaching that maximum.
*
*/ Example Use: !#!

/************************************************************************************************************/
	
int NumLWeapons();			ZASM Instruction: 
					LWPNCOUNT

/**
* Returns the number of Link weapon projectiles currently present on the screen.
* This includes things like Link's arrows, bombs, magic, etc. Note that this
* value is only correct up until the next call of Waitframe().
*
*/ Example Use: !#!

/************************************************************************************************************/
	
lweapon LoadLWeapon(int num);		ZASM Instruction: 
					LOADLWEAPONR
					LOADLWEAPONV

/**
* Returns a pointer to the num-th lweapon on the current screen. The return
* value is undefined unless 1 <= num <= NumLWeapons().
*
*/ Example Use: !#!

/************************************************************************************************************/
	
lweapon CreateLWeapon(int type);	ZASM Instruction: 
					CREATELWEAPONR
					CREATELWEAPONV

/**
* Creates an lweapon of the given type at (0,0). Use the LW_ constants in
* std.zh to pass into this method. The return value is a pointer to the
* new lweapon.
* The maximum number of lweapons on any given screen is 255. ZC will NOT report an
* error to allegro.log if you try to create lweapons after reaching that maximum. 
* The maximum instances for lweapons, and eweapons are independent.
* This cap is of *all* lweapons, of any type. Mixing types will not increase this cap.
*
*/ Example Use: !#!

/************************************************************************************************************/
	
int NumEWeapons();			ZASM Instruction: 
					EWPNCOUNT

/**
* Returns the number of Enemy weapon projectiles currently present on the screen.
* This includes things like Enemy arrows, bombs, magic, etc. Note that this
* value is only correct up until the next call of Waitframe().
*
*/ Example Use: !#!

/************************************************************************************************************/
	
eweapon LoadEWeapon(int num);		ZASM Instruction: 
					LOADEWEAPONR
					LOADEWEAPONV

/**
* Returns a pointer to the numth eweapon on the current screen. The return
* value is undefined unless 1 <= num <= NumEWeapons().
*
*/ Example Use: !#!

/************************************************************************************************************/
	
eweapon CreateEWeapon(int type);	ZASM Instruction: 
					CREATEEWEAPONR
					CREATEEWEAPONV

/**
* Creates an eweapon of the given type at (0,0). Use the EW_ constants in
* std.zh to pass into this method. The return value is a pointer to the
* new lweapon.
* The maximum number of eweapons on any given screen is 255. ZC will NOT report an
* error to allegro.log if you try to create eweapons after reaching that maximum. 
* The maximum instances for eweapons, and lweapons are independent.
* This cap is of *all* eweapons, of any type. Mixing types will not increase this cap.
*
*/ Example Use: !#!

/************************************************************************************************************/

bool isSolid(int x, int y);		ZASM Instruction: 
					ISSOLID

/**
* Returns true if the screen position (x, y) is solid - that is, if it
* is within the solid portion of a combo on layers 0, 1 or 2. If either
* x or y exceed the screen's bounds, then it will return false.
* It will also return false if the only applicable solid combo is a solid
* water combo that has recently been 'dried' by the whistle.
*
*/ Example Use: !#!

/************************************************************************************************************/

void ClearSprites(int spritelist);	ZASM Instruction: 
					CLEARSPRITESR
					CLEARSPRITESV

/**
* Clears all of a certain kind of sprite from the screen. Use the SL_
* constants in std.zh to pass into this method.
*
*/ Example Use: !#!

/************************************************************************************************************/

				//===============================//
				//    SCRIPT DRAWING COMMANDS    //
				//===============================//
				
		/* These commands use the Allegro 4 drawing primitives to render drawn
		    effects directly to the screen. You may draw to the screen immediately
		    which is considered RT_SCREEN (see: Render Targets), or you may change
		    to another render target (1 through 5) and issue your drawing commands,
		    then render that back to the screen. 
		    
		    All render targets have eight valid layers, 0 through 7. 
		    Drawing colour 0 to a layer of a bitmap render target erases a section of that,
		    creating a transparent area on that layer. Any transparent area that extends 
		    through all layers will be drawn as transparent when rendered back to the screen
		    if 'bool mask' is set true. 
		    
		    Drawing colour 0 directly to a screen layer is undefined. 
		    
		    Please note: For all draw primitives, if the quest rule 'Subscreen Appears
		    Above Sprites' is set,passing the layer argument as 7 will allow drawing
		    on top of the subscreen.
		    
		    Tha maximum number of script drawing instructions per frame is 1000. 
	
	
	

	
	/**
	* Draws a rectangle on the specified layer of the current screen, using
	* (x,y) as the top-left corner and (x2,y2) as the bottom-right corner.
	* Then scales the rectangle uniformly about its center by the given
	* factor.
	* Lastly, a rotation, centered about the point (rx, ry), is performed
	* counterclockwise using an angle of rangle degrees.
	* A filled rectangle is drawn if fill is true; otherwise, this method
	* draws a wireframe.
	* The rectangle is drawn using the specified index into the entire
	* 256-element palette: for instance, passing in a color of 17 would
	* use color 1 of cset 1.
	* Opacity controls how transparent the rectangle will be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	* //Defining Opacity at a value of 129 or higher, will enable XOR drawing.
	* { ! Check Opacity 0 }
	*/
	void Rectangle(int layer, int x, int y, int x2, int y2, int color, float scale, int rx, int ry, int rangle, bool fill, int opacity);
	RECTR
	RECT
	
	/**
	* Draws a circle on the specified layer of the current screen with
	* center (x,y) and radius scale*radius.
	* Then performs a rotation counterclockwise, centered about the point
	* (rx, ry), using an angle of rangle degrees.
	* A filled circle is drawn if fill is true; otherwise, this method
	* draws a wireframe.
	* The circle is drawn using the specified index into the entire
	* 256-element palette: for instance, passing in a color of 17 would
	* use color 1 of cset 1.
	* Opacity controls how transparent the circle will be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void Circle(int layer, int x, int y, int radius, int color, float scale, int rx, int ry, int rangle, bool fill, int opacity);
	CIRCLE
	CIRCLER

	/**
	* Draws an arc of a circle on the specified layer of the current
	* screen. The circle in question has center (x,y) and radius
	* scale*radius.
	* The arc beings at startangle degrees counterclockwise from standard
	* position, and ends at endangle degress counterclockwise from standard
	* position. The behavior of this function is undefined unless
	* 0 <= endangle-startangle < 360.
	* The arc is then rotated about the point (rx, ry) using an angle of
	* rangle radians.
	* If closed is true, a line is drawn from the center of the circle to
	* each endpoint of the arc, forming a sector of the circle. If fill
	* is also true, a filled sector is drawn instead.
	* The arc or sector is drawn using the specified index into the entire
	* 256-element palette: for instance, passing in a color of 17 would
	* use color 1 of cset 1.
	* Opacity controls how transparent the arc will be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void Arc(int layer, int x, int y, int radius, int startangle, int endangle, int color, float scale, int rx, int ry, int rangle, bool closed, bool fill, int opacity);
	ARC
	ARCR

	/**
	* Draws an ellipse on the specified layer of the current screen with
	* center (x,y), x-axis radius xradius, and y-axis radius yradius.
	* Then performs a rotation counterclockwise, centered about the point
	* (rx, ry), using an angle of rangle degrees.
	* A filled ellipse is drawn if fill is true; otherwise, this method
	* draws a wireframe.
	* The ellipse is drawn using the specified index into the entire
	* 256-element palette: for instance, passing in a color of 17 would
	* use color 1 of cset 1.
	* Opacity controls how transparent the ellipse will be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void Ellipse(int layer, int x, int y, int xradius, int yradius, int color, float scale, int rx, int ry, int rangle, bool fill, int opacity);
	ELLIPSE2
	ELLIPSER

	/**
	* Draws a cardinal spline on the specified layer of the current screen
	* between (x1,y1) and (x4,y4)
	* The spline is drawn using the specified index into the entire
	* 256-element palette: for instance, passing in a color of 17 would
	* use color 1 of cset 1.
	* Opacity controls how transparent the ellipse will be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void Spline(int layer, int x1, int y1, int x2, int y2, int x3, int y3,int x4, int y4, int color, int opacity);
	SPLINER
	SPLINE
	

	/**
	* Draws a line on the specified layer of the current screen between
	* (x,y) and (x2,y2).
	* Then scales the line uniformly by a factor of scale about the line's
	* midpoint.
	* Finally, performs a rotation counterclockwise, centered about the
	* point (rx, ry), using an angle of rangle degrees.
	* The line is drawn using the specified index into the entire
	* 256-element palette: for instance, passing in a color of 17 would
	* use color 1 of cset 1.
	* Opacity controls how transparent the line will be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void Line(int layer, int x, int y, int x2, int y2, int color, float scale, int rx, int ry, int rangle, int opacity);
	LINE
	LINER

	/**
	* Draws a raw pixel on the specified layer of the current screen
	* at (x,y).
	* Then performs a rotation counterclockwise, centered about the point
	* (rx, ry), using an angle of rangle degrees.
	* The point is drawn using the specified index into the entire
	* 256-element palette: for instance, passing in a color of 17 would
	* use color 1 of cset 1.
	* Opacity controls how transparent the point will be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void PutPixel(int layer, int x, int y, int color, int rx, int ry, int rangle, int opacity);
	PUTPIXEL
	PUTPIXELR

	/**
	* Draws a block of tiles on the specified layer of the current screen,
	* starting at (x,y), using the specified cset.
	* Starting with the specified tile, this method copies a block of size
	* blockh x blockw from the tile sheet to the screen. This method's
	* behavior is undefined unless 1 <= blockh, blockw <= 20.
	* Scale specifies the actual size in pixels! So scale 1 would mean it is
	* only one pixel in size. To use the default sizes of block w,h you must
	* set xscale and yscale to -1. These values are not independant of one another,
	* so you cannot set xscale and leave yscale at -1.
	* rx, ry : these work now, just like the other primitives.
	* rangle performs a rotation clockwise using an angle of rangle degrees.
	* Flip specifies how the tiles should be flipped when drawn:
	* 0: No flip
	* 1: Horizontal flip
	* 2: Vertical flip
	* 3: Both (180 degree rotation)
	* If transparency is true, the tiles' transparent regions will be
	* respected.
	* Opacity controls how transparent the solid portions of the tiles will
	* be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void DrawTile(int layer, int x, int y, int tile, int blockw, int blockh, int cset, int xscale, int yscale, int rx, int ry, int rangle, int flip, bool transparency, int opacity);
	DRAWTILE
	DRAWTILER

	/**
	* Optimized and simpler version of DrawTile()
	* Draws a single tile on the current screen much in the same way as DrawTile().
	* See DrawTile() for an explanation on what these arguments do.
	*/
	void FastTile( int layer, int x, int y, int tile, int cset, int opacity );
	FASTTILER

	/**
	* Draws a combo on the specified layer of the current screen,
	* starting at (x,y), using the specified cset.
	* Starting with the specified tile referenced by the combo,
	* this method copies a block of size
	* blockh x blockw from the tile sheet to the screen. This method's
	* behavior is undefined unless 1 <= blockh, blockw <= 20.
	* Scale specifies the actual size in pixels! So scale 1 would mean it is
	* only one pixel in size. To use the default sizes of block w,h you must
	* set xscale and yscale to -1. These values are not independant of one another,
	* so you cannot set xscale and leave yscale at -1.
	* rx, ry : works now :
	* rangle performs a rotation clockwise using an angle of rangle degrees.
	* Flip specifies how the tiles should be flipped when drawn:
	* 0: No flip
	* 1: Horizontal flip
	* 2: Vertical flip
	* 3: Both (180 degree rotation)
	* If transparency is true, the tiles' transparent regions will be
	* respected.
	* Opacity controls how transparent the solid portions of the tiles will
	* be. 
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void DrawCombo(int layer, int x, int y, int combo, int w, int h, int cset, int xscale, int yscale, int rx, int ry, int rangle, int frame, int flip, bool transparency, int opacity);
	DRAWCOMBO
	DRAWCOMBOR

	/**
	* Optimized and simpler version of DrawCombo()
	* Draws a single combo on the current screen much in the same way as DrawCombo().
	* See DrawCombo() for an explanation on what these arguments do.
	*/
	void FastCombo( int layer, int x, int y, int combo, int cset, int opacity );
	FASTCOMBOR

	/**
	* Prints the message string with given ID onto the screen.
	* If string is 0, the currently displayed message is removed.
	* This method's behavior is undefined if string is less than 0
	* or greater than the total number of messages in the quest.
	*/
	void Message(int string);
	MSGSTRR
	MSGSTRV

	/**
	* Draws a single ASCII character 'glyph' on the specified layer of the current screen,
	* using the specified font index (see std.zh for FONT_* list to pass to this method),
	* starting at (x,y), using the specified color as the foreground color
	* and background_color as the background color. * NOTE * Use -1 for a transparent background.
	* The arguments width and height may be used to draw the glyph
	* of any arbitrary size begining at 1 pixel up to 512 pixels large. (more than four times the size of the screen)
	* Passing 0 or negative values to this will use the default fonts w and h.
	* Opacity controls how transparent the is.
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void DrawCharacter(int layer, int x, int y, int font, int color, int background_color, int width, int height, int glyph, int opacity );
	DRAWCHARR
	
	/**
	* Draws a zscript 'int' or 'float' on the specified layer of the current screen,
	* using the specified font index (see std.zh for FONT_* list to pass to this method),
	* starting at (x,y), using the specified color as the foreground color
	* and background_color as the background color. * NOTE * Use -1 for a transparent background.
	* The arguments width and height may be used to draw the number
	* of any arbitrary size begining at 1 pixel up to 512 pixels large.
	* Passing 0 or negative values to this will use the default fonts w and h.
	* The number can be rendered as type 'int' or 'float' by setting the argument
	* "number_decimal_places", which is only valid if set to 0 or <= 4.
	* Opacity controls how transparent the is.
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void DrawInteger(int layer, int x, int y, int font, int color, int background_color, int width, int height, int number, int number_decimal_places, int opacity);
	DRAWINTR

	/**
	* Prints a NULL terminated string up to 256 characters from an int array
	* containing ASCII data (*ptr) on the specified layer of the current screen,
	* using the specified font index (see std.zh for FONT_* list to pass to this method),
	* using the specified color as the foreground color
	* and background_color as the background color. * NOTE * Use -1 for a transparent background.
	* The array pointer should be passed as the argument for '*ptr', ie.
	* int string[] = "Example String"; Screen->DrawString(l,x,y,f,c,b_c,fo,o,string);
	* int format tells the engine how to format the string. (see std.zh for TF_* list to pass to this method)
	* Opacity controls how transparent the message is.
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	// (Psuedo) 3D drawing
	*/
	void DrawString( int layer, int x, int y, int font, int color, int background_color, int format, int ptr[], int opacity );
	DRAWSTRINGR
	
	/**
	* Draws a quad on the specified layer with the corners x1,y1 through x4,y4.
	* Corners are drawn in a counterclockwise order starting from x1,y1. ( So
	* if you draw a "square" for example starting from the bottom-right corner
	* instead of the usual top-left, the the image will be textured onto the
	* quad so it appears upside-down. -yes, these are rotatable. )
	* From there a single or block of tiles or combos is then texture mapped
	* onto the quad using the arguments w, h, cset, flip, and render_mode.
	* A positive vale in texture will draw the image from the tilesheet pages,
	* whereas a negative value will be drawn from the combo page. 0 will draw combo number 0.
	* Both w and h are undefined unless 1 <= blockh, blockw <= 16, and it is a power of
	* two. ie: 1, 2 are acceptable, but 2, 15 are not.


	* Flip specifies how the tiles/combos should be flipped when drawn:
	* 0: No flip
	* 1: Horizontal flip
	* 2: Vertical flip
	* 3: Both (180 degree rotation)
	*** See std.zh for a list of all available render_mode arguments.
	*/
	void Quad( int layer, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4,int w, int h, int cset, int flip, int texture, int render_mode);
	QUADR
	
	/**
	* Draws a triangle on the specified layer with the corners x1,y1 through x4,y4.
	* Corners are drawn in a counterclockwise order starting from x1,y1.
	* From there a single or block of tiles or combos is then texture mapped
	* onto the triangle using the arguments w, h, cset, flip, and render_mode.
	* A positive value in texture will draw the image from the tilesheet pages,
	* whereas a negative value will be drawn from the combo page. 0 will draw combo number 0.
	* Both w and h are undefined unless 1 <= blockh, blockw <= 16, and it is a power of
	* two. ie: 1, 2 are acceptable, but 2, 15 are not.
	* Flip specifies how the tiles/combos should be flipped when drawn:
	* 0: No flip
	* 1: Horizontal flip
	* 2: Vertical flip
	* 3: Both (180 degree rotation)
	*** See std.zh for a list of all available render_mode arguments.
	*/
	void Triangle( int layer, int x1, int y1, int x2, int y2, int x3, int y3,int w, int h, int cset, int flip, int texture, int render_mode);
	TRIANGLER

	/**
	* Draws a triangle on the specified layer with the corners x1,y1 through x4,y4.
	* Corners are drawn in a counterclockwise order starting from x1,y1.
	* From there a single or block of tiles or combos is then texture mapped
	* onto the triangle using the arguments w, h, cset, flip, and render_mode.
	* A positive value in texture will draw the image from the tilesheet pages,
	* whereas a negative value will be drawn from the combo page. 0 will draw combo number 0.
	* Both w and h are undefined unless 1 <= blockh, blockw <= 16, and it is a power of
	* two. ie: 1, 2 are acceptable, but 2, 15 are not.
	* Flip specifies how the tiles/combos should be flipped when drawn:
	* 0: No flip
	* 1: Horizontal flip
	* 2: Vertical flip
	* 3: Both (180 degree rotation)
	*** See std.zh for a list of all available render_mode arguments.
	*/
	void Triangle3D( //sdci[1]=layer
	    //sdci[2]=pos[9]
	    //sdci[3]=uv[6]
	    //sdci[4]=color[3]
	    //sdci[5]=size[2]
	    //sdci[6]=flip
	    //sdci[7]=tile/combo
	    //sdci[8]=polytype);
	
	ZASM: TRIANGLE3DR

void Triangle3D( int layer, int pos[9], int uv[6], int csets[3], int size[2], int flip, int tile, int polytype );

* [9]pos - x, y, z positions of the 3 corners.
	* [6]uv - x, y texture coordinates of the given texture.
	* [3]csets - of the corners to interpolate between.
	* [2]size - w, h, of the texture.

	/**
	* Draws a Quad on the specified layer similar to Quad.
	* [12]pos - x, y, z positions of the 4 corners.
	* [8]uv - x, y texture coordinates of the given texture.
	* [4]csets - of the corners to interpolate between.
	* [2]size - w, h, of the texture.
	*** See std.zh for a list of all available render_mode arguments.
	*/
	void Quad3D( int layer, int pos[], int uv[], int cset[], int size[], int flip, int texture, int render_mode );
	QUAD3DR

	/**
	* Sets the target bitmap for all succesive drawing commands.
	* These can be directly to the screen or any one of the available off-screen bitmaps,
	* which are generally categorized as -1(screen) or 0-bitmapNumber(off-screen).
	*** See std.zh for a complete list of valid render targets (RT_*).
	*/
	void SetRenderTarget( int bitmap_id );
	SETRENDERTARGET
	
	/**
	* Draws a source rect from off-screen Bitmap with id of bitmap_id onto
	* an area of the screen described by dest rect at the given layer.
	* *Example:
	* Screen->Bitmap( 6, myBitmapId, 0, 0, 16, 16, 79, 57, 32, 32, 0, true );
	* //Would draw a 16x16 area starting at the upper-left corner of source bitmap to
	* //layer 6 of the current screen at coordinates 79,57 with a width and height of 32.
	***Note* Script drawing functions are enqueued and executed in a frame-by-frame basis 
	based on the order of which layer they need to be drawn to. Drawing to or from
	seperate render tagets or bitmaps is no exception! So keep in mind in order to 
	eliminate unwanted drawing orders or bugs.
	// Screen/Layer Drawing
	*/
	void DrawBitmap( int layer, int bitmap_id, int source_x, int source_y, int source_w, int source_h, int dest_x, int dest_y, int dest_w, int dest_h, float rotation, bool mask);
	BITMAPR
	
	/**
	* Draws an entire Layer from source_screen on source_map on the specified layer of the current screen at (x,y).
	* If rotation is not zero, it(the entire layer) will rotate about its center.
	* Opacity controls how transparent the solid portions of the tiles will
	* You may use OP_TRANS (64) for a translucent (50%) image, or OP_OPAQUE (128)
	* for an opaque (100%) image. Other values are **ignored**, and will be treated 
	* as translucent (OP_TRANS, or 64).
	*/
	void DrawLayer(int layer, int source_map, int source_screen, int source_layer, int x, int y, float rotation, int opacity);
	DRAWLAYERR
	
	/**
	* Draws an entire screen from screen on map on the specified layer of the current screen at (x,y).
	* If rotation is not zero, it(the entire screen) will rotate about its center.
	*/
	void DrawScreen(int layer, int map, int source_screen, int x, int y, float rotation);
	DRAWSCREENR
	
	
Undocumented / ZASM Exclusive

FLOODFILL

}; //Screen


//====================================
//--- Item Functions and Variables ---
//====================================

class item
{
	/**
	* Returns whether this item pointer is still valid. An item pointer
	* becomes invalid when Link picks up the item, the item fades away,
	* or Link leaves the screen. Accessing any variables using an
	* invalid item pointer prints an error message to allegro.log and
	* does nothing.
	*/
	bool isValid();

	/**
	* The item's X position on the screen, in pixels. Float values passed to this will be cast to int.
	*/
	int X;

	/**
	* The item's Y position on the screen, in pixels. Float values passed to this will be cast to int.
	*/
	int Y;

	/**
	* The item's upward velocity, in pixels. If negative, the item will fall.
	* The downward acceleration of Gravity (in Init Data) modifies this value every frame.
	*/
	int Jump;

	/**
	* An integer representing how the item is to be drawn. Use one of the
	* DS_ constants in std.zh to set or compare this value.
	*/
	int DrawStyle;

	/**
	* This item's ID number. Use the I_ constants to compare this value. The effect of writing to this field is currently undefined.
	*/
	int ID;

	/**
	* The starting tile of the item's animation.
	*/
	int OriginalTile;

	/**
	* The current tile associated with this item.
	*/
	int Tile;

	/**
	* This item's CSet.
	*/
	int CSet;

	/**
	* The CSet used during this item's flash frames, if this item flashes.
	*/
	int FlashCSet;

	/**
	* The number of frames in this item's animation.
	*/
	int NumFrames;

	/**
	* The tile that is this item's current animation frame.
	*/
	int Frame;

	/**
	* The speed at which this item animates, in screen frames.
	*/
	int ASpeed;

	/**
	* The amount of time the animation is suspended after the last frame,
	* before the animation restarts, in item frames. That is, the total
	* number of screen frames of extra wait is Delay*ASpeed.
	*/
	int Delay;

	/**
	* Whether or not the item flashes. A flashing item alternates between
	* its CSet and its FlashCSet.
	*/
	bool Flash;

	/**
	* Whether and how the item's tiles should be flipped.
	* 0: No flip
	* 1: Horizontal flip
	* 2: Vertical flip
	* 3: Both (180 degree rotation)
	*/
	int Flip;

	/**
	* The pickup flags of the item, which determine what happens when Link
	* picks up the item. Its value consists of flags OR'd (|) together; use
	* the IP_ constants in std.zh to set or compare these values.
	* A special note about IP_ENEMYCARRIED: if the Quest Rule "Hide Enemy-
	* Carried Items" is set, then an item carried by an enemy will have its
	* X and Y values set to -128 while the enemy is carrying it. If this
	* flag is removed from such an item, then it will be moved to the enemy's
	* on-screen location.
	* If you are not comfortable with performing binary operations, use the ItemPickup functions from std.zh.
	*/
	int Pickup;

	/**
	* Whether to extend the sprite of the item.
	*/
	int Extend;

	/**
	* The number of tile columns composing the sprite.
	* Writing to this is ignored unless Extend is set to values >=3.
	*/
	int TileWidth;

	/**
	* The number of tile rows composing the sprite.
	* Writing to this is ignored unless Extend is set to values >=3.
	*/
	int TileHeight;

	/**
	* The width of the sprite's hitbox, or collision rectangle.
	*/
	int HitWidth;

	/**
	* The height of the sprite's hitbox, or collision rectangle.
	*/
	int HitHeight;

	/**
	* The Z-axis height of the sprite's hitbox, or collision rectangle.
	* The greater it is, the higher Link must jump or fly over the sprite to avoid picking up the item.
	*/
	int HitZHeight;

	/**
	* The X offset of the sprite's hitbox, or collision rectangle.
	* Setting it to positive or negative values will move the sprite's hitbox left or right.
	*/
	int HitXOffset;

	/**
	* The Y offset of the sprite's hitbox, or collision rectangle.
	* Setting it to positive or negative values will move the sprite's hitbox up or down.
	*/
	int HitYOffset;

	/**
	* The X offset of the sprite.
	* Setting it to positive or negative values will move the sprite's tiles left or right relative to its position.
	*/
	int DrawXOffset;

	/**
	* The Y offset of the sprite.
	* Setting it to positive or negative values will move the sprite's tiles up or down relative to its position.
	*/
	int DrawYOffset;

	/**
	* The Z offset of the sprite.
	*/
	int DrawZOffset;

	/**
	* An array of 16 miscellaneous variables for you to use as you please.
	* Note that lweapons and eweapons possess exactly the same attributes,
	* although their designation affects how they are treated by the engine.
	* The values here correspond to both the lweapon and eweapon type.
	*/
	float Misc[];
	
}; //item


//======================================
//--- Weapon Functions and Variables ---
//======================================

class weapon
{
	/**
	* Returns whether this weapon pointer is still valid. A weapon pointer
	* becomes invalid when the weapon fades away or disappears
	* or Link leaves the screen. Accessing any variables using an
	* invalid weapon pointer prints an error message to allegro.log and
	* does nothing.
	*/
	bool isValid();

	/**
	* Reads a 'Weapons/Misc' sprite entry in your quest file, and assigns
	* the OriginalTile, Tile, OriginalCSet, CSet, FlashCSet, NumFrames,
	* Frame, ASpeed, Flip and Flash variables of this weapon based on
	* this entry's data. Passing negative values, and values greater than
	* 255, will do nothing.
	*/
	void UseSprite(int id);

	/**
	* Ensures that the weapon's graphic is drawn behind Link and enemies.
	*/
	bool Behind;

	/**
	* The weapon's ID number. Use the LW_ or EW_ constants to compare
	* this value. The effect of writing to this field is currently undefined.
	*/
	int ID;

	/**
	* The weapon's X position on the screen, in pixels. Float values passed
	* to this will be cast to int.
	*/
	int X;

	/**
	* The weapon's Y position on the screen, in pixels. Float values passed
	* to this will be cast to int.
	*/
	int Y;

	/**
	* The weapon's Z position on the screen, in pixels. Float values passed
	* to this will be cast to int.
	*/
	int Z;

	/**
	* The weapon's falling speed on the screen. Bombs, Bait and
	* Fire obey gravity.
	*/
	int Jump;

	/**
	* An integer representing how the weapon is to be drawn. Use one of the
	* DS_ constants in std.zh to set or compare this value.
	*/
	int DrawStyle;

	/**
	* The direction that the weapon is facing. Used by certain weapon types
	* to determine movement, shield deflection and such.
	*/
	int Dir;

	/**
	* The starting tile of the weapon's animation.
	*/
	int OriginalTile;

	/**
	* The current tile associated with this weapon.
	*/
	int Tile;

	/**
	* The starting CSet of the weapon's animation.
	*/
	int OriginalCSet;

	/**
	* This weapon's current CSet.
	*/
	int CSet;

	/**
	* The CSet used during this weapon's flash frames, if this weapon flashes.
	*/
	int FlashCSet;

	/**
	* The number of frames in this weapon's animation.
	*/
	int NumFrames;

	/**
	* The weapon's current animation frame.
	*/
	int Frame;

	/**
	* The speed at which this weapon animates, in screen frames.
	*/
	int ASpeed;

	/**
	* The amount of damage that this weapon causes to Link/an enemy upon contact.
	*/
	int Damage;

	/**
	* Usually associated with the weapon's velocity. A Step of 100
	* typically means that the weapon moves at approximately one pixel
	* per animation frame.
	*/
	int Step;

	/**
	* The weapon's current angle in clockwise radians; used by certain weapon
	* types with angular movement. 0 = right, PI/2 = down, etc. Note: if you
	* want Link's shield to interact with the weapon correctly, you must set
	* its Dir to a direction that approximates this angle.
	*/
	int Angle;

	/**
	* Specifies whether a weapon has angular movement.
	*/
	bool Angular;

	/**
	* Whether the weapon will use the system's code to work out collisions with
	* Link and/or enemies (depending on weapon type). Initialised as 'true'.
	*/
	bool CollDetection;

	/**
	* The current state of the weapon. Important to keep track of. A value of
	* -1 indicates that it is active, and moves according to the weapon's
	* Dir, Step, Angular, and Angle values. Use -1 if you want the engine to
	* handle movement and collision. Use any value below -1 if you want a
	* dummy weapon that you can control on your own.
	* Given a deadstate value of -10, a weapon will turn of its collision
	* detection and movement. If it has a positive value, it will
	* decrement once per frame until it equals 0, whereupon the weapon is
	* removed. If you want to remove the weapon, write one of the WDS_
	* constants in std.zh (appropriate for the weapon) to this variable.
	*/
	int DeadState;

	/**
	* Whether or not the weapon flashes. A flashing weapon alternates between
	* its CSet and its FlashCSet.
	*/
	bool Flash;

	/**
	* Whether and how the weapon's tiles should be flipped.
	* 0: No flip
	* 1: Horizontal flip
	* 2: Vertical flip
	* 3: Both (180 degree rotation)
	*/
	int Flip;

	/**
	* Whether to extend the sprite of the weapon.
	*/
	int Extend;

	/**
	* The number of tile columns composing the sprite.
	* Writing to this is ignored unless Extend is set to values >=3.
	*/
	int TileWidth;

	/**
	* The number of tile rows composing the sprite.
	* Writing to this is ignored unless Extend is set to values >=3.
	*/
	int TileHeight;

	/**
	* The width of the sprite's hitbox, or collision rectangle.
	*/
	int HitWidth;

	/**
	* The height of the sprite's hitbox, or collision rectangle.
	*/
	int HitHeight;

	/**
	* The Z-axis height of the sprite's hitbox, or collision rectangle.
	* The greater it is, the higher Link must jump or fly over the sprite
	* to avoid taking damage.
	*/
	int HitZHeight;

	/**
	* The X offset of the sprite's hitbox, or collision rectangle.
	* Setting it to positive or negative values will move the sprite's
	* hitbox left or right.
	*/
	int HitXOffset;

	/**
	* The Y offset of the sprite's hitbox, or collision rectangle.
	* Setting it to positive or negative values will move the sprite's
	* hitbox up or down.
	*/
	int HitYOffset;

	/**
	* The X offset of the sprite.
	* Setting it to positive or negative values will move the sprite's
	* tiles left or right relative to its position.
	*/
	int DrawXOffset;

	/**
	* The Y offset of the sprite.
	* Setting it to positive or negative values will move the sprite's
	* tiles up or down relative to its position.
	*/
	int DrawYOffset;

	/**
	* The Z offset of the sprite.
	*/
	int DrawZOffset;

	/**
	* An array of 16 miscellaneous variables for you to use as you please.
	*/
	float Misc[];
	
}; //weapon

typedef weapon lweapon;
typedef weapon eweapon;
	

//=========================================
//--- Itemdata Functions and Variables ---
//=========================================

class itemdata
{

	/**
	* The original values of the item's 8 D input values are they are stored in the
	* .qst file, regardles of whether they have been modified by ZScript.
	*/
	float InitD[];
	
	/**
	* Loads the item this itemdata is attributed to's name into 'buffer'
	*/
	void GetName(int buffer[]);

	/**
	* The kind of item to which this class belongs (swords, boomerangs,
	* potions, etc.) Use the IC_ constants in std.zh to set or compare this
	* value.
	*/
	int Family;

	/**
	* The level of this item. Higher-level items replace lower-level items
	* when they are picked up.
	*/
	int Level;

	/**
	* The item's power, for most items this is amount of damage dealt but is
	* used for other values in some items (ie. Roc's Feather)
	*/
	int Power;

	/**
	* Corresponds to the "Increase Amount" entry in the Item Editor.
	* The value of this data member can have two meanings:
	* If Amount & 0x8000 is 1, the drain counter for this item is set
	* to Amount & 0x3FFF. The game then slowly fills the counter of this item
	* (see Counter below) out of the drain counter. Gaining rupees uses the
	* drain counter, for example.
	* is set to Amount when the item is picked up.
	* If Amount & 0x8000 is 0, the counter of this item is increased, if
	* Amount & 0x4000 is 1, or decreased, if Amount & 0x4000 is 0, by
	* Amount & 0x3FFF when the item is picked up.
	*/
	int Amount;

	/**
	* Corresponds to the "Full Max" entry in the Item Editor.
	* In conjunction with MaxIncrement (see below) this value controls how
	* the maximum value of the counter of this item (see Counter below) is
	* modified when the item is picked up. If MaxIncrement is nonzero at that
	* time, the counter's new maximum value is at that time set to the
	* minimum of its current value plus MaxIncrement, Max.
	* If Max is less than the current maximum of the counter, Max is ignored
	* and that maximum is used instead.
	* Notice that as a special case, if Max = MaxIncrement, the counter's
	* maximum value will be forced equal to Max.
	*/
	int Max;

	/**
	* Corresponds to the "+Max" entry in the Item Editor.
	* In conjunction with Max (see above) this value controls how the
	* maximum value of the counter of this item (see Counter below) is
	* modified when the item is picked up. If MaxIncrement is nonzero at that
	* time, the counter's new maximum value is at that time set to the
	* minimum of its current value plus MaxIncrement, and Max.
	* If Max is less than the current maximum of the counter, Max is ignored
	* and that maximum is used instead.
	*/
	int MaxIncrement;

	/**
	* Corresponds to the "Equipment Item" checkbox in the Item Editor.
	* If true, Link will keep the item, and it will show up as an item or
	* equipment in the subscreen. If false, it may modify the current value
	* or maximum value of its counter (see Counter below), then disappear.
	* The White Sword and Raft, for instance, have Keep true, and keys and
	* rupees have Keep false.
	*/
	bool Keep;

	/**
	* Corresponds to the "Counter Reference" entry in the Item Editor.
	* The game counter whose current and modified values might be modified
	* when the item is picked up (see Amount, Max, and MaxIncrement above.)
	* Use the CT_ constants in std.zh to set or compare this value.
	*/
	int Counter;

	/**
	* Corresponds to the "Sound" entry on the action tab in the Item Editor.
	*/
	int UseSound;
	
}; //itemdata


//====================================
//--- Game Functions and Variables ---
//====================================

namespace Game
{

	

	/**
	* Retrieves the number of the current screen within the current map.
	*/
	int GetCurScreen();

	/**
	* Retrieves the number of the current screen within the current DMap.
	*/
	int GetCurDMapScreen();

	/**
	* Retrieves the number of the dungeon level of the current DMap. Multiple
	* DMaps can have the same dungeon level - this signifies that they share
	* a map, compass, level keys and such.
	*/
	int GetCurLevel();

	/**
	* Retrieves the number of the current map.
	*/
	int GetCurMap();

	/**
	* Returns the number of the current DMap.
	*/
	int GetCurDMap();

	/**
	* An array of 512 integers, containing the DMap's flags ORed (|) together.
	* Use the 'DMF_' constants, or the 'DMapFlag()' functions from std.zh if you are not comfortable with binary.
	*/
	int DMapFlags[];

	/**
	* An array of 512 integers containing each DMap's level
	*/
	int DMapLevel[];

	/**
	* An array of 512 integers containing each DMap's compass screen
	*/
	int DMapCompass[];

	/**
	* An array of 512 integers containing each DMap's continue screen
	*/
	int DMapContinue[];

	/**
	* An array of 512 integers containing each DMap's MIDI.
	* Positive numbers are for custom MIDIs, and negative values are used for
	* the built-in game MIDIs. Because of the way DMap MIDIs are handled
	* internally, however, built-in MIDIs besides the overworld, dungeon, and
	* level 9 songs won't match up with Game->PlayMIDI() and Game->GetMIDI().
	*/
	int DMapMIDI[];

	/**
	* Loads DMap with ID 'DMap's name into 'buffer'.
	* See std.zh for appropriate buffer size.
	*/
	void GetDMapName(int DMap, int buffer[]);

	/**
	* Loads DMap with ID 'DMap's title into 'buffer'.
	* See std.zh for appropriate buffer size.
	*/
	void GetDMapTitle(int DMap, int buffer[]);

	/**
	* Loads DMap with ID 'DMap's intro string into 'buffer'.
	* See std.zh for appropriate buffer size.
	*/
	void GetDMapIntro(int DMap, int buffer[]);

	/**
	* An array of 512 integers containing the X offset of each DMap.
	* Game->DMapOffset is read-only; while setting it is not syntactically
	* incorrect, it does nothing.
	*/
	int DMapOffset[];

	/**
	* An array of 512 integers containing the map used by each DMap.
	* Game->DMapMap is read-only; while setting it is not syntactically
	* incorrect, it does nothing.
	*/
	int DMapMap[];

	/**
	* The number of times Link has perished during this quest.
	*/
	int NumDeaths;

	/**
	* The current cheat level of the quest player.
	*/
	int Cheat;

	/**
	* Returns the time elapsed in this quest, in 60ths of a second. The
	* return value is undefined if TimeValid is false (see below).
	*/
	int Time;

	/**
	* True if the elapsed quest time can be determined for the current quest.
	*/
	bool TimeValid;

	/**
	* This value is true if the current quest session was loaded from a saved
	* game, false if the quest was started fresh.
	*/
	bool HasPlayed;

	/**
	* This value is true if the game is running in standalone mode, false if not.
	* Game->Standalone is read-only; while setting it is not syntactically
	* incorrect, it does nothing.
	*/
	bool Standalone;

	/**
	* The number of NPCs (enemies and guys) on screen i of this map, where
	* i is the index used to access this array. This array is exclusively used
	* to determine which enemies had previously been killed, and thus won't
	* return, when you re-enter a screen.
	*/
	int GuyCount[];
	?NPCCOUNT This is attached to Screen Information in ffscript.cpp

	/**
	* The DMap where Link will be respawned after quitting and reloading the game.
	*/
	int ContinueDMap;

	/**
	* The map screen where Link will be respawned after quitting and reloading the game.
	*/
	int ContinueScreen;

	/**
	* The DMap where Link will be respawned after dying and continuing.
	*/
	int LastEntranceDMap;

	/**
	* The map screen where Link will be respawned after dying and continuing.
	*/
	int LastEntranceScreen;

	/**
	* The current value of the game counters. Use the CR_ constants in
	* std.zh to index into this array.
	*/
	int Counter[];

	/**
	* The current maximum value of the game counters. Use the CR_ constants
	* in std.zh to index into this array.
	*/
	int MCounter[];

	/**
	* The current value of the game drain counters. Use the CR_ constants
	* in std.zh to index into this array.
	* Note that if the player hasn't acquired the '1/2 Magic Upgrade' yet,
	* then setting the CR_MAGIC drain counter to a negative value will
	* drain the magic counter by 2 per frame rather than 1.
	*/
	int DCounter[];

	/**
	* An array of miscellaneous game values, such as number of heart
	* containers and magic drain rate. Use the GEN_ constants in std.zh
	* to index into this array.
	*/
	int Generic[];

	/**
	* The exploration items (map, compass, boss key etc.) of dungeon level i
	* currently under the possession of the player, where i is
	* the index used to access this array. Each element of this
	* array consists of flags OR'd (|) together; use the LI_ constants in
	* std.zh to set or compare these values.
	*/
	int LItems[];

	/**
	* The number of level keys of level i currently under the possession of
	* the player, where i is the index used to access this array.
	*/
	int LKeys[];

	/**
	* Returns the screen flags from screen 'screen' on map 'map',
	* interpreted in the same way as Screen->Flags
	*/
	int GetScreenFlags(int map, int screen, int flagset);

	/**
	* Returns the enemy flags from screen 'screen' on map 'map',
	* interpreted in the same way as Screen->EFlags
	*/
	int GetScreenEFlags(int map, int screen, int flagset);
	GETSCREENEFLAGS

	/**
	* As with State, but retrieves the miscellaneous flags of any screen,
	* not just the current one. This function is undefined if map is less
	* than 1 or greater than the maximum map number of your quest, or if
	* screen is greater than 127.
	* Note: Screen numbers in ZQuest are usually displayed in hexadecimal.
	* Use the ST_ constants in std.zh for the flag parameter.
	*/
	bool GetScreenState(int map, int screen, int flag);

	/**
	* As with State, but sets the miscellaneous flags of any screen, not
	* just the current one. This function is undefined if map is less than
	* 1 or greater than the maximum map number of your quest, or if
	* screen is greater than 127.
	* Note: Screen numbers in ZQuest are usually displayed in hexadecimal.
	* Use the ST_ constants in std.zh for the flag parameter.
	*/
	void SetScreenState(int map, int screen, int flag, bool value);

	/**
	* Retrieves the value of D[reg] on the given screen of the current
	* DMap.
	*/
	float GetScreenD(int screen, int reg);

	/**
	* Sets the value of D[reg] on the given screen of the current DMap.
	*/
	void SetScreenD(int screen, int reg, float value);

	/**
	* Retrieves the value of D[reg] on the given screen of the given
	* DMap.
	*/
	float GetDMapScreenD(int dmap, int screen, int reg);

	/**
	* Sets the value of D[reg] on the given screen of the given DMap.
	*/
	void SetDMapScreenD(int dmap, int screen, int reg, float value);

	/**
	* Retrieves the itemdata pointer corresponding to the given item.
	* Use the item pointer ID variable or I_ constants in std.zh as values.
	*/
	itemdata LoadItemData(int item);
	LOADITEMDATAR
	LOADITEMDATAV

	/**
	* Plays one of the quest's sound effects. Use the SFX_ constants in
	* std.zh as values of soundid.
	*/
	void PlaySound(int soundid);

	/**
	* Changes the current screen MIDI to MIDIid.
	* Will revert to the DMap (or screen) MIDI upon leaving the screen.
	*/
	void PlayMIDI(int MIDIid);

	/**
	* Returns the current screen MIDI that is playing.
	* Positive numbers are for custom MIDIs, and negative values are used
	* for the built-in game MIDIs.
	*/
	int GetMIDI();

	/**
	* Play the specified enhanced music if it's available. If the music
	* cannot be played, the current music will continue. The music will
	* revert to normal upon leaving the screen.
	* Returns true if the music file was loaded successfully.
	* The filename cannot be more than 255 characters. If the music format
	* does not support multiple tracks, the track argument will be ignored.
	*/
	bool PlayEnhancedMusic(int filename[], int track);

	/**
	* Load the filename of the given DMap's enhanced music into buf.
	* buf should be at least 256 elements in size.
	*/
	void GetDMapMusicFilename(int dmap, int buf[]);

	/**
	* Returns the given DMap's enhanced music track. This is valid but
	* meaningless if the music format doesn't support multiple tracks.
	*/
	int GetDMapMusicTrack(int dmap);

	/**
	* Sets the specified DMap's enhanced music to the given filename and
	* track number. If the music format does not support multiple tracks,
	* the track argument will be ignored. The filename must not be more
	* than 255 characters.
	*/
	void SetDMapEnhancedMusic(int dmap, int filename[], int track);

	/**
	* Grabs a particular combo reference from anywhere in the game
	* world, based on map (NOT DMap), screen number, and position.
	* Don't forget that the screen index should be in hexadecimal,
	* and that maps are counted from 1 upwards.
	* Position is considered an index, treated the same way as in
	* Screen->ComboD[].
	*/
	int GetComboData(int map, int screen, int position);

	/**
	* Sets a particular combo reference anywhere in the game world,
	* based on map (NOT DMap), screen number, and position.
	* Don't forget that the screen index should be in hexadecimal,
	* and that maps are counted from 1 upwards.
	* Position is considered an index, treated the same way as in
	* Screen->ComboD[].
	*/
	void SetComboData(int map, int screen, int position, int value);

	/**
	* Grabs a particular combo's CSet from anywhere in the game
	* world, based on map (NOT DMap), screen number, and position.
	* Position is considered an index, treated the same way as in
	* Screen->ComboC[].
	*/
	int GetComboCSet(int map, int screen, int position);

	/**
	* Sets a particular combo's CSet anywhere in the game world,
	* based on map (NOT DMap), screen number, and position. Position
	* is considered an index, treated the same way as in Screen->ComboC[].
	*/
	void SetComboCSet(int map, int screen, int position, int value);

	/**
	* Grabs a particular combo's placed flag from anywhere in the game
	* world, based on map (NOT DMap), screen number, and position.
	* Position is considered an index, treated the same way as in
	* Screen->ComboF[].
	*/
	int GetComboFlag(int map, int screen, int position);

	/**
	* Sets a particular combo's placed flag anywhere in the game world,
	* based on map (NOT DMap), screen number, and position. Position
	* is considered an index, treated the same way as in Screen->ComboF[].
	*/
	void SetComboFlag(int map, int screen, int position, int value);

	/**
	* Grabs a particular combo's type from anywhere in the game
	* world, based on map (NOT DMap), screen number, and position.
	* Position is considered an index, treated the same way as in
	* Screen->ComboT[]. Note that you are grabbing an actual combo
	* attribute as referenced by the combo on screen you're
	* referring to.
	*/
	int GetComboType(int map, int screen, int position);

	/**
	* Sets a particular combo's type anywhere in the game world,
	* based on map (NOT DMap), screen number, and position. Position
	* is considered an index, treated the same way as in Screen->ComboT[].
	* Note that you are grabbing an actual combo attribute as referenced
	* by the combo on screen you're referring to, which means that
	* setting this attribute will affect ALL references to this combo
	* throughout the quest.
	*/
	void SetComboType(int map, int screen, int position, int value);

	/**
	* Grabs a particular combo's inherent flag from anywhere in the game
	* world, based on map (NOT DMap), screen number, and position.
	* Position is considered an index, treated the same way as in
	* Screen->ComboI[]. Note that you are grabbing an actual combo
	* attribute as referenced by the combo on screen you're
	* referring to.
	*/
	int GetComboInherentFlag(int map, int screen, int position);

	/**
	* Sets a particular combo's inherent flag anywhere in the game world,
	* based on map (NOT DMap), screen number, and position. Position
	* is considered an index, treated the same way as in Screen->ComboI[].
	* Note that you are grabbing an actual combo attribute as referenced
	* by the combo on screen you're referring to, which means that
	* setting this attribute will affect ALL references to this combo
	* throughout the quest.
	*/
	void SetComboInherentFlag(int map, int screen, int position, int value);

	/**
	* Grabs a particular combo's solidity flag from anywhere in the game
	* world, based on map (NOT DMap), screen number, and position.
	* Position is considered an index, treated the same way as in
	* Screen->ComboS[]. Note that you are grabbing an actual combo
	* attribute as referenced by the combo on screen you're
	* referring to.
	*/
	int GetComboSolid(int map, int screen, int position);

	/**
	* Sets a particular combo's solidity anywhere in the game world,
	* based on map (NOT DMap), screen number, and position. Position
	* is considered an index, treated the same way as in Screen->ComboS[].
	* Note that you are grabbing an actual combo attribute as referenced
	* by the combo on screen you're referring to, which means that
	* setting this attribute will affect ALL references to this combo
	* throughout the quest.
	*/
	void SetComboSolid(int map, int screen, int position, int value);

	/**
	* Returns the tile used by combo 'combo'
	*/
	int ComboTile(int combo);

	/**
	* Loads the current save file's name into 'buffer'
	* Buffer should be at least 9 elements long
	*/
	void GetSaveName(int buffer[]);

	/**
	* Sets the current file's save name to 'name'
	* Buffer should be no more than 9 elements
	*/
	void SetSaveName(int name[]);

	/**
	* Ends the current game and returns to the file select screen
	*/
	void End();

	/**
	* Saves the current game
	*/
	void Save();

	/**
	* Displays the save screen. Returns true if the user chose to save, false otherwise.
	*/
	bool ShowSaveScreen();

	/**
	* Displays the save and quit screen.
	*/
	void ShowSaveQuitScreen();

	/**
	* Loads 'string' into 'buffer'. Use the function from std.zh
	* to remove trailing ' ' characters whilst loading.
	*/
	void GetMessage(int string, int buffer[]);
	
	/**
	* Returns the number of the script with the given name or -1 if there is
	* no such script.
	*/
	int GetFFCScript(int name[]);
	
	/**
	* If this is false, the "Click to Freeze" setting will not function, ensuring
	* that the script can use the mouse freely. This overrides the setting rather
	* than changing it, so remembering and restoring the initial value is unnecessary.
	*/
	bool ClickToFreezeEnabled;
}; //Game


//===================================
//--- NPC Functions and Variables ---
//===================================

class npc
{
	/**
	* Returns whether or not this NPC pointer is still valid. A pointer
	* becomes invalid if the enemy dies or Link leaves the screen.
	* Trying to access any variable of an invalid NPC pointer prints
	* an error to allegro.log and does nothing.
	*/
	bool isValid();

	/**
	* Loads the npc's name into 'buffer'. To load an NPC from an ID rather than a pointer,
	* use 'GetNPCName' from std.zh
	*/
	void GetName(int buffer[]);

	/**
	* The NPC's enemy ID number.
	* npc->ID is read-only; while setting it is not syntactically incorrect, it does nothing.
	*/
	int ID;

	/**
	* The NPC's Type. Use the NPCT_ constants in std.zh to compare this value.
	* npc->Type is read-only; while setting it is not syntactically incorrect, it does nothing.
	*/
	int Type;

	/**
	* The NPC's current X coordinate, in pixels. Float values passed to this will be cast to int.
	*/
	int X;

	/**
	* The NPC's current Y coordinate, in pixels. Float values passed to this will be cast to int.
	*/
	int Y;

	/**
	* The NPC's current Z coordinate, in pixels. Float values passed to this will be cast to int.
	*/
	int Z;

	/**
	* The NPC's upward velocity, in pixels. If negative, the NPC will fall.
	* The downward acceleration of Gravity (in Init Data) modifies this value every frame.
	*/
	int Jump;

	/**
	* The direction the NPC is facing. Use the DIR_ constants in std.zh to
	* set and compare this value.
	*/
	int Dir;

	/**
	* The rate at which the NPC changes direction. For a point of reference,
	* the "Octorok (Magic)" enemy has a rate of 16. The effect of writing to
	* this field is currently undefined.
	*/
	int Rate;

	/**
	* The extent to which the NPC stands still while moving around the
	* screen. As a point of reference, the Zols and Gels have haltrate of
	* 16. The effect of writing to this field is currently undefined.
	*/
	int Haltrate;

	/**
	* How likely the NPC is to move towards Link.
	* The effect of writing to this field is currently undefined.
	*/
	int Homing;

	/**
	* How likely the NPC is to move towards bait.
	* The effect of writing to this field is currently undefined.
	*/
	int Hunger;

	/**
	* The NPC's movement speed. A Step of 100 usually means that
	* the enemy moves at approximately one pixel per animation frame.
	* As a point of reference, the "Octorok (Magic)" enemy has
	* a step of 200. The effect of writing to this field is
	* currently undefined.
	*/
	int Step;

	/**
	* Whether the NPC will use the system's code to work out collisions with Link
	* Initialised as 'true'.
	*/
	bool CollDetection;

	/**
	* The the NPC's animation frame rate, in screen frames. The effect of
	* writing to this field is currently undefined.
	*/
	int ASpeed;

	/**
	* The way the NPC is animated. Use the DS_ constants in std.zh to set or
	* compare this value. The effect of writing to this field is currently undefined.
	*/
	int DrawStyle;

	/**
	* The NPC's current hitpoints. A weapon with a Power of 1 removes 2
	* hitpoints.
	*/
	int HP;

	/**
	* The amount of damage dealt to an unprotected Link when he touches this NPC, in
	* quarter-hearts.
	*/
	int Damage;

	/**
	* The amount of damage dealt to an unprotected Link by this NPC's weapon, in
	* quarter-hearts.
	*/
	int WeaponDamage;

	/**
	* The time, in frames, that the NPC will be stunned. Some types of enemies cannot be stunned.
	*/
	int Stun;

	/**
	* The number of the starting tile used by this NPC.
	*/
	int OriginalTile;

	/**
	* The current tile associated with this NPC. The effect of writing to this variable is undefined.
	*/
	int Tile;

	/**
	* The weapon used by this enemy. Use the WPN_ constants (NOT the EW_ constants)
	* in std.zh to set or compare this value.
	*/
	int Weapon;

	/**
	* The items that the NPC might drop when killed. Use the IS_ constants
	* in std.zh to set or compare this value.
	*/
	int ItemSet;

	/**
	* The CSet used by this NPC.
	*/
	int CSet;

	/**
	* The boss pallete used by this NPC; this pallete is only used if CSet
	* is 14 (the reserved boss cset). Use the BPAL_ constants in std.zh to
	* set or compare this value.
	*/
	int BossPal;

	/**
	* The sound effects emitted by the enemy. Use the SFX_ constants in
	* std.zh to set or compare this value.
	*/
	int SFX;

	/**
	* Whether to extend the sprite of the enemy.
	*/
	int Extend;

	/**
	* The number of tile columns composing the sprite.
	* Writing to this is ignored unless Extend is set to values >=3.
	*/
	int TileWidth;

	/**
	* The number of tile rows composing the sprite.
	* Writing to this is ignored unless Extend is set to values >=3.
	*/
	int TileHeight;

	/**
	* The width of the sprite's hitbox, or collision rectangle.
	*/
	int HitWidth;

	/**
	* The height of the sprite's hitbox, or collision rectangle.
	*/
	int HitHeight;

	/**
	* The Z-axis height of the sprite's hitbox, or collision rectangle.
	* The greater it is, the higher Link must jump or fly over the sprite to avoid taking damage.
	*/
	int HitZHeight;

	/**
	* The X offset of the sprite's hitbox, or collision rectangle.
	* Setting it to positive or negative values will move the sprite's hitbox left or right.
	*/
	int HitXOffset;

	/**
	* The Y offset of the sprite's hitbox, or collision rectangle.
	* Setting it to positive or negative values will move the sprite's hitbox up or down.
	*/
	int HitYOffset;

	/**
	* The X offset of the sprite.
	* Setting it to positive or negative values will move the sprite's tiles left or right relative to its position.
	*/
	int DrawXOffset;

	/**
	* The Y offset of the sprite. In non-sideview screens, this is usually -2.
	* Setting it to positive or negative values will move the sprite's tiles up or down relative to its position.
	*/
	int DrawYOffset;

	/**
	* The Z offset of the sprite. This is ignored unless Extend is set to values >=3.
	*/
	int DrawZOffset;

	/**
	* The npc's Defense values, as an array of 18 integers. Use the NPCD_ and NPCDT_ constants
	* in std.zh to set or compare these values.
	*/
	int Defense[];

	/**
	* The npc's Miscellaneous Attributes, as an array of ten integers.
	* They are read-only; while setting them is not syntactically incorrect, it does nothing.
	*/
	int Attributes[];

	/**
	* The npc's Misc. Flags as 14 bits ORed together, starting with 'Damaged by Power 0 Weapons',
	* and working down the flags in the order they are shown in the Enemy Editor.
	* npc->MiscFlags is read-only; while setting it is not syntactically incorrect, it does nothing.
	* If you are not comfortable with binary operations, you can use 'GetNPCMiscFlag' from std.zh
	*/
	int MiscFlags;

	/**
	* An array of 16 miscellaneous variables for you to use as you please.
	*/
	float Misc[];

	/**
	* Breaks the enemy's shield if it has one. This works even if the flag
	* "Hammer Can Break Shield" is not checked.
	void BreakShield();

}; //npc



